var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  authenticators: () => authenticators,
  authenticatorsRelations: () => authenticatorsRelations,
  externalMeetings: () => externalMeetings,
  externalMeetingsRelations: () => externalMeetingsRelations,
  insertAuthenticatorSchema: () => insertAuthenticatorSchema,
  insertExternalMeetingSchema: () => insertExternalMeetingSchema,
  insertInvitationSchema: () => insertInvitationSchema,
  insertLoginEventSchema: () => insertLoginEventSchema,
  insertMeetingSchema: () => insertMeetingSchema,
  insertNotificationSchema: () => insertNotificationSchema,
  insertProjectMemberSchema: () => insertProjectMemberSchema,
  insertProjectSchema: () => insertProjectSchema,
  insertTaskSchema: () => insertTaskSchema,
  insertUserSchema: () => insertUserSchema,
  insertUserSettingsSchema: () => insertUserSettingsSchema,
  invitations: () => invitations,
  invitationsRelations: () => invitationsRelations,
  loginEvents: () => loginEvents,
  loginEventsRelations: () => loginEventsRelations,
  meetingParticipants: () => meetingParticipants,
  meetingParticipantsRelations: () => meetingParticipantsRelations,
  meetings: () => meetings,
  meetingsRelations: () => meetingsRelations,
  notifications: () => notifications,
  notificationsRelations: () => notificationsRelations,
  projectMembers: () => projectMembers,
  projectMembersRelations: () => projectMembersRelations,
  projects: () => projects,
  projectsRelations: () => projectsRelations,
  tasks: () => tasks,
  tasksRelations: () => tasksRelations,
  userSettings: () => userSettings,
  userSettingsRelations: () => userSettingsRelations,
  users: () => users,
  usersRelations: () => usersRelations
});
import { sql, relations } from "drizzle-orm";
import { pgTable, text, timestamp, integer, boolean, jsonb, uuid } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var users, projects, tasks, meetings, projectMembers, invitations, meetingParticipants, notifications, userSettings, externalMeetings, usersRelations, projectsRelations, tasksRelations, meetingsRelations, projectMembersRelations, meetingParticipantsRelations, notificationsRelations, userSettingsRelations, invitationsRelations, externalMeetingsRelations, authenticators, authenticatorsRelations, loginEvents, loginEventsRelations, insertUserSchema, insertProjectSchema, insertTaskSchema, insertMeetingSchema, insertProjectMemberSchema, insertNotificationSchema, insertUserSettingsSchema, insertInvitationSchema, insertAuthenticatorSchema, insertLoginEventSchema, insertExternalMeetingSchema;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    users = pgTable("users", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      username: text("username").notNull().unique(),
      email: text("email").notNull().unique(),
      password: text("password").notNull(),
      name: text("name").notNull(),
      role: text("role").notNull().default("member"),
      avatar: text("avatar"),
      createdAt: timestamp("created_at").defaultNow()
    });
    projects = pgTable("projects", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      name: text("name").notNull(),
      description: text("description"),
      status: text("status").notNull().default("active"),
      // active, completed, paused
      progress: integer("progress").notNull().default(0),
      // 0-100
      ownerId: uuid("owner_id").references(() => users.id).notNull(),
      dueDate: timestamp("due_date"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    tasks = pgTable("tasks", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      title: text("title").notNull(),
      description: text("description"),
      status: text("status").notNull().default("todo"),
      // todo, in_progress, completed
      priority: text("priority").notNull().default("medium"),
      // low, medium, high, urgent
      projectId: uuid("project_id").references(() => projects.id).notNull(),
      assigneeId: uuid("assignee_id").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id),
      dueDate: timestamp("due_date"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    meetings = pgTable("meetings", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      title: text("title").notNull(),
      description: text("description"),
      projectId: uuid("project_id").references(() => projects.id),
      scheduledAt: timestamp("scheduled_at").notNull(),
      duration: integer("duration").notNull(),
      // in minutes
      recordingUrl: text("recording_url"),
      transcription: text("transcription"),
      aiSummary: text("ai_summary"),
      extractedTasks: jsonb("extracted_tasks"),
      createdById: uuid("created_by_id").references(() => users.id).notNull(),
      createdAt: timestamp("created_at").defaultNow(),
      // Recurring meeting fields
      isRecurring: boolean("is_recurring").notNull().default(false),
      recurrenceType: text("recurrence_type"),
      // daily, weekly, monthly, yearly
      recurrenceInterval: integer("recurrence_interval").default(1),
      // every N days/weeks/months
      recurrenceEndDate: timestamp("recurrence_end_date"),
      recurringParentId: uuid("recurring_parent_id"),
      // Links to parent recurring series
      recurrencePattern: text("recurrence_pattern")
      // Additional pattern info (e.g., weekdays, specific dates)
    });
    projectMembers = pgTable("project_members", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      projectId: uuid("project_id").references(() => projects.id).notNull(),
      userId: uuid("user_id").references(() => users.id).notNull(),
      role: text("role").notNull().default("member"),
      // owner, admin, member
      joinedAt: timestamp("joined_at").defaultNow()
    });
    invitations = pgTable("invitations", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      projectId: uuid("project_id").references(() => projects.id).notNull(),
      inviterUserId: uuid("inviter_user_id").references(() => users.id).notNull(),
      inviteeEmail: text("invitee_email").notNull(),
      role: text("role").notNull().default("member"),
      // admin, member, collaborator
      status: text("status").notNull().default("pending"),
      // pending, accepted, declined, expired
      token: text("token").notNull().unique(),
      expiresAt: timestamp("expires_at").notNull(),
      createdAt: timestamp("created_at").defaultNow(),
      respondedAt: timestamp("responded_at")
    });
    meetingParticipants = pgTable("meeting_participants", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      meetingId: uuid("meeting_id").references(() => meetings.id).notNull(),
      userId: uuid("user_id").references(() => users.id).notNull(),
      joinedAt: timestamp("joined_at").defaultNow()
    });
    notifications = pgTable("notifications", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: uuid("user_id").references(() => users.id).notNull(),
      title: text("title").notNull(),
      message: text("message").notNull(),
      type: text("type").notNull(),
      // meeting, task, project, ai_insight
      read: boolean("read").notNull().default(false),
      data: jsonb("data"),
      createdAt: timestamp("created_at").defaultNow()
    });
    userSettings = pgTable("user_settings", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: uuid("user_id").references(() => users.id).notNull().unique(),
      emailNotifications: boolean("email_notifications").notNull().default(true),
      morningBriefing: boolean("morning_briefing").notNull().default(true),
      lunchReminder: boolean("lunch_reminder").notNull().default(true),
      endOfDaySummary: boolean("end_of_day_summary").notNull().default(true),
      meetingReminders: boolean("meeting_reminders").notNull().default(true),
      taskDeadlineAlerts: boolean("task_deadline_alerts").notNull().default(true),
      aiInsights: boolean("ai_insights").notNull().default(true),
      workingHoursStart: text("working_hours_start").notNull().default("09:00"),
      workingHoursEnd: text("working_hours_end").notNull().default("18:00"),
      urgentOnly: boolean("urgent_only").notNull().default(false),
      outlookCalendarUrl: text("outlook_calendar_url"),
      outlookCalendarEnabled: boolean("outlook_calendar_enabled").notNull().default(false),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    externalMeetings = pgTable("external_meetings", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      externalId: text("external_id").notNull(),
      // ID from external system (Outlook event ID)
      userId: uuid("user_id").references(() => users.id).notNull(),
      projectId: uuid("project_id").references(() => projects.id),
      // Optional project association
      title: text("title").notNull(),
      description: text("description"),
      startTime: timestamp("start_time").notNull(),
      endTime: timestamp("end_time").notNull(),
      location: text("location"),
      attendees: jsonb("attendees"),
      // Array of attendee emails
      source: text("source").notNull().default("outlook"),
      // outlook, google, etc.
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    usersRelations = relations(users, ({ many }) => ({
      ownedProjects: many(projects),
      assignedTasks: many(tasks),
      createdMeetings: many(meetings),
      projectMemberships: many(projectMembers),
      meetingParticipations: many(meetingParticipants),
      notifications: many(notifications),
      settings: many(userSettings),
      sentInvitations: many(invitations),
      authenticators: many(authenticators),
      loginEvents: many(loginEvents),
      externalMeetings: many(externalMeetings)
    }));
    projectsRelations = relations(projects, ({ one, many }) => ({
      owner: one(users, { fields: [projects.ownerId], references: [users.id] }),
      tasks: many(tasks),
      meetings: many(meetings),
      members: many(projectMembers),
      invitations: many(invitations),
      externalMeetings: many(externalMeetings)
    }));
    tasksRelations = relations(tasks, ({ one }) => ({
      project: one(projects, { fields: [tasks.projectId], references: [projects.id] }),
      assignee: one(users, { fields: [tasks.assigneeId], references: [users.id] }),
      updatedByUser: one(users, { fields: [tasks.updatedBy], references: [users.id] })
    }));
    meetingsRelations = relations(meetings, ({ one, many }) => ({
      project: one(projects, { fields: [meetings.projectId], references: [projects.id] }),
      createdBy: one(users, { fields: [meetings.createdById], references: [users.id] }),
      participants: many(meetingParticipants)
    }));
    projectMembersRelations = relations(projectMembers, ({ one }) => ({
      project: one(projects, { fields: [projectMembers.projectId], references: [projects.id] }),
      user: one(users, { fields: [projectMembers.userId], references: [users.id] })
    }));
    meetingParticipantsRelations = relations(meetingParticipants, ({ one }) => ({
      meeting: one(meetings, { fields: [meetingParticipants.meetingId], references: [meetings.id] }),
      user: one(users, { fields: [meetingParticipants.userId], references: [users.id] })
    }));
    notificationsRelations = relations(notifications, ({ one }) => ({
      user: one(users, { fields: [notifications.userId], references: [users.id] })
    }));
    userSettingsRelations = relations(userSettings, ({ one }) => ({
      user: one(users, { fields: [userSettings.userId], references: [users.id] })
    }));
    invitationsRelations = relations(invitations, ({ one }) => ({
      project: one(projects, { fields: [invitations.projectId], references: [projects.id] }),
      inviter: one(users, { fields: [invitations.inviterUserId], references: [users.id] })
    }));
    externalMeetingsRelations = relations(externalMeetings, ({ one }) => ({
      user: one(users, { fields: [externalMeetings.userId], references: [users.id] }),
      project: one(projects, { fields: [externalMeetings.projectId], references: [projects.id] })
    }));
    authenticators = pgTable("authenticators", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: uuid("user_id").references(() => users.id).notNull(),
      credentialId: text("credential_id").notNull().unique(),
      credentialPublicKey: text("credential_public_key").notNull(),
      counter: integer("counter").notNull().default(0),
      credentialDeviceType: text("credential_device_type").notNull(),
      // singleDevice, multiDevice
      credentialBackedUp: boolean("credential_backed_up").notNull().default(false),
      transports: jsonb("transports"),
      // Array of transport methods (usb, nfc, ble, internal)
      deviceName: text("device_name"),
      // User-friendly name for the device
      createdAt: timestamp("created_at").defaultNow(),
      lastUsedAt: timestamp("last_used_at")
    });
    authenticatorsRelations = relations(authenticators, ({ one }) => ({
      user: one(users, { fields: [authenticators.userId], references: [users.id] })
    }));
    loginEvents = pgTable("login_events", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: uuid("user_id").references(() => users.id).notNull(),
      type: text("type").notNull(),
      // login_success, login_failure, logout, biometric_login, biometric_failure
      method: text("method").notNull(),
      // password, biometric
      deviceName: text("device_name"),
      userAgent: text("user_agent"),
      ipAddress: text("ip_address"),
      location: text("location"),
      // Optional: City, Country if IP geolocation is available
      sessionDuration: integer("session_duration"),
      // Duration in minutes, set on logout
      createdAt: timestamp("created_at").defaultNow()
    });
    loginEventsRelations = relations(loginEvents, ({ one }) => ({
      user: one(users, { fields: [loginEvents.userId], references: [users.id] })
    }));
    insertUserSchema = createInsertSchema(users).omit({
      id: true,
      createdAt: true
    });
    insertProjectSchema = createInsertSchema(projects).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    }).extend({
      dueDate: z.string().optional().nullable().transform((val) => val ? new Date(val) : null)
    });
    insertTaskSchema = createInsertSchema(tasks).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    }).extend({
      dueDate: z.string().optional().nullable().transform((val) => val ? new Date(val) : null)
    }).partial({ dueDate: true });
    insertMeetingSchema = createInsertSchema(meetings).omit({
      id: true,
      createdAt: true,
      recurringParentId: true
      // This gets set automatically
    }).extend({
      // Transform date fields for form handling
      scheduledAt: z.date(),
      // Include recurring fields explicitly
      isRecurring: z.boolean().default(false),
      recurrenceType: z.enum(["daily", "weekly", "monthly", "yearly"]).optional(),
      recurrenceInterval: z.number().min(1).max(99).optional(),
      recurrenceEndDate: z.string().optional(),
      recurrencePattern: z.string().optional()
    });
    insertProjectMemberSchema = createInsertSchema(projectMembers).omit({
      id: true,
      joinedAt: true
    });
    insertNotificationSchema = createInsertSchema(notifications).omit({
      id: true,
      createdAt: true
    });
    insertUserSettingsSchema = createInsertSchema(userSettings).omit({
      id: true,
      updatedAt: true
    });
    insertInvitationSchema = createInsertSchema(invitations).omit({
      id: true,
      createdAt: true,
      respondedAt: true
    }).extend({
      expiresAt: z.string().transform((val) => new Date(val))
    });
    insertAuthenticatorSchema = createInsertSchema(authenticators).omit({
      id: true,
      createdAt: true,
      lastUsedAt: true
    });
    insertLoginEventSchema = createInsertSchema(loginEvents).omit({
      id: true,
      createdAt: true
    });
    insertExternalMeetingSchema = createInsertSchema(externalMeetings).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    }).extend({
      startTime: z.string().transform((val) => new Date(val)),
      endTime: z.string().transform((val) => new Date(val))
    });
  }
});

// server/db.ts
import { Pool } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
var pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    if (!process.env.DATABASE_URL) {
      throw new Error(
        "DATABASE_URL must be set. Did you forget to provision a database?"
      );
    }
    pool = new Pool({ connectionString: process.env.DATABASE_URL });
    db = drizzle({ client: pool, schema: schema_exports });
  }
});

// server/storage.ts
var storage_exports = {};
__export(storage_exports, {
  DatabaseStorage: () => DatabaseStorage,
  storage: () => storage
});
import { eq, desc, and, or, count, sql as sql2, gte, lt, asc, inArray } from "drizzle-orm";
var DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_schema();
    init_db();
    DatabaseStorage = class {
      async getAllUsers() {
        const allUsers = await db.select().from(users);
        return allUsers;
      }
      async getUser(id) {
        const [user] = await db.select().from(users).where(eq(users.id, id));
        return user || void 0;
      }
      async getUserByUsername(username) {
        const [user] = await db.select().from(users).where(eq(users.username, username));
        return user || void 0;
      }
      async getUserByEmail(email) {
        const [user] = await db.select().from(users).where(eq(users.email, email));
        return user || void 0;
      }
      async createUser(insertUser) {
        const [user] = await db.insert(users).values(insertUser).returning();
        return user;
      }
      async updateUser(id, updates) {
        const [user] = await db.update(users).set(updates).where(eq(users.id, id)).returning();
        if (!user) {
          throw new Error("User not found");
        }
        return user;
      }
      async getProjects(userId) {
        const result = await db.select({ projects }).from(projects).leftJoin(projectMembers, eq(projects.id, projectMembers.projectId)).where(or(eq(projects.ownerId, userId), eq(projectMembers.userId, userId))).orderBy(desc(projects.updatedAt));
        const userProjects = result.map((r) => r.projects);
        const projectsWithCounts = await Promise.all(
          userProjects.map(async (project) => {
            const memberCount = await this.getProjectMemberCount(project.id);
            return { ...project, memberCount };
          })
        );
        return projectsWithCounts;
      }
      async getProjectMemberCount(projectId) {
        const project = await this.getProject(projectId);
        if (!project) return 0;
        const [memberCount] = await db.select({ count: count() }).from(projectMembers).where(eq(projectMembers.projectId, projectId));
        return (memberCount?.count || 0) + 1;
      }
      async getProject(id) {
        const [project] = await db.select().from(projects).where(eq(projects.id, id));
        return project || void 0;
      }
      async createProject(project) {
        const [newProject] = await db.insert(projects).values(project).returning();
        return newProject;
      }
      async updateProject(id, updates) {
        const [project] = await db.update(projects).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(projects.id, id)).returning();
        return project;
      }
      async deleteProject(id) {
        await db.delete(tasks).where(eq(tasks.projectId, id));
        await db.delete(meetings).where(eq(meetings.projectId, id));
        await db.delete(projectMembers).where(eq(projectMembers.projectId, id));
        await db.delete(invitations).where(eq(invitations.projectId, id));
        await db.delete(projects).where(eq(projects.id, id));
      }
      async getTasks(projectId, userId) {
        if (projectId && userId) {
          return await db.select().from(tasks).where(and(eq(tasks.projectId, projectId), eq(tasks.assigneeId, userId))).orderBy(desc(tasks.createdAt));
        } else if (projectId) {
          return await db.select().from(tasks).where(eq(tasks.projectId, projectId)).orderBy(desc(tasks.createdAt));
        } else if (userId) {
          return await db.select().from(tasks).where(eq(tasks.assigneeId, userId)).orderBy(desc(tasks.createdAt));
        }
        return await db.select().from(tasks).orderBy(desc(tasks.createdAt));
      }
      async getTasksByProject(projectId) {
        return await db.select().from(tasks).where(eq(tasks.projectId, projectId)).orderBy(desc(tasks.createdAt));
      }
      async getTask(id) {
        const [task] = await db.select().from(tasks).where(eq(tasks.id, id));
        return task || void 0;
      }
      async createTask(task) {
        const [newTask] = await db.insert(tasks).values(task).returning();
        if (newTask.projectId) {
          await this.updateProjectProgress(newTask.projectId);
        }
        return newTask;
      }
      async updateTask(id, updates, userId) {
        const [task] = await db.update(tasks).set({
          ...updates,
          updatedAt: /* @__PURE__ */ new Date(),
          updatedBy: userId || updates.updatedBy
        }).where(eq(tasks.id, id)).returning();
        if (updates.status && task.projectId) {
          await this.updateProjectProgress(task.projectId);
        }
        return task;
      }
      async deleteTask(id) {
        const taskToDelete = await this.getTask(id);
        await db.delete(tasks).where(eq(tasks.id, id));
        if (taskToDelete?.projectId) {
          await this.updateProjectProgress(taskToDelete.projectId);
        }
      }
      async deleteTasks(ids) {
        if (ids.length === 0) return;
        const tasksToDelete = await Promise.all(ids.map((id) => this.getTask(id)));
        await db.delete(tasks).where(inArray(tasks.id, ids));
        const projectIds = Array.from(new Set(
          tasksToDelete.filter((task) => task?.projectId).map((task) => task.projectId)
        ));
        await Promise.all(projectIds.map((projectId) => this.updateProjectProgress(projectId)));
      }
      async getMeetings(userId, projectId) {
        if (projectId) {
          const result = await db.select({ meetings }).from(meetings).leftJoin(meetingParticipants, eq(meetings.id, meetingParticipants.meetingId)).where(
            and(
              eq(meetings.projectId, projectId),
              or(eq(meetings.createdById, userId), eq(meetingParticipants.userId, userId))
            )
          ).orderBy(desc(meetings.scheduledAt));
          return result.map((r) => r.meetings);
        } else {
          const result = await db.select({ meetings }).from(meetings).leftJoin(meetingParticipants, eq(meetings.id, meetingParticipants.meetingId)).where(
            or(eq(meetings.createdById, userId), eq(meetingParticipants.userId, userId))
          ).orderBy(desc(meetings.scheduledAt));
          return result.map((r) => r.meetings);
        }
      }
      async getMeeting(id) {
        const [meeting] = await db.select().from(meetings).where(eq(meetings.id, id));
        return meeting || void 0;
      }
      async createMeeting(meeting) {
        const processedMeeting = {
          ...meeting,
          recurrenceEndDate: meeting.recurrenceEndDate ? new Date(meeting.recurrenceEndDate) : null
        };
        const [newMeeting] = await db.insert(meetings).values([processedMeeting]).returning();
        if (meeting.isRecurring && meeting.recurrenceType) {
          await this.generateRecurringInstances(newMeeting);
        }
        return newMeeting;
      }
      async generateRecurringInstances(parentMeeting) {
        if (!parentMeeting.isRecurring || !parentMeeting.recurrenceType || !parentMeeting.scheduledAt) {
          return;
        }
        const startDate = new Date(parentMeeting.scheduledAt);
        const endDate = parentMeeting.recurrenceEndDate ? new Date(parentMeeting.recurrenceEndDate) : null;
        const interval = parentMeeting.recurrenceInterval || 1;
        const maxInstances = 100;
        let currentDate = new Date(startDate);
        let instanceCount = 0;
        while (instanceCount < maxInstances && (!endDate || currentDate <= endDate)) {
          if (instanceCount > 0) {
            let shouldCreateInstance = true;
            if (parentMeeting.recurrenceType === "weekly" && parentMeeting.recurrencePattern) {
              const dayOfWeek = currentDate.getDay();
              shouldCreateInstance = parentMeeting.recurrencePattern.includes(dayOfWeek.toString());
            }
            if (shouldCreateInstance) {
              await db.insert(meetings).values({
                title: parentMeeting.title,
                description: parentMeeting.description,
                scheduledAt: new Date(currentDate),
                duration: parentMeeting.duration,
                createdById: parentMeeting.createdById,
                projectId: parentMeeting.projectId,
                recordingUrl: parentMeeting.recordingUrl,
                isRecurring: false,
                recurrenceType: null,
                recurrenceInterval: null,
                recurrenceEndDate: null,
                recurringParentId: parentMeeting.id,
                recurrencePattern: null
              });
            }
          }
          switch (parentMeeting.recurrenceType) {
            case "daily":
              currentDate.setDate(currentDate.getDate() + interval);
              break;
            case "weekly":
              currentDate.setDate(currentDate.getDate() + 7 * interval);
              break;
            case "monthly":
              currentDate.setMonth(currentDate.getMonth() + interval);
              break;
            case "yearly":
              currentDate.setFullYear(currentDate.getFullYear() + interval);
              break;
          }
          instanceCount++;
          if (!endDate && instanceCount > 104) {
            break;
          }
        }
      }
      async updateMeeting(id, updates) {
        const processedUpdates = { ...updates };
        if (updates.recurrenceEndDate && typeof updates.recurrenceEndDate === "string") {
          processedUpdates.recurrenceEndDate = new Date(updates.recurrenceEndDate);
        }
        const [meeting] = await db.update(meetings).set(processedUpdates).where(eq(meetings.id, id)).returning();
        return meeting;
      }
      async deleteMeeting(id) {
        await db.delete(meetings).where(eq(meetings.id, id));
      }
      // External Meetings Implementation
      async getExternalMeetings(userId, projectId) {
        if (projectId) {
          return await db.select().from(externalMeetings).where(and(eq(externalMeetings.userId, userId), eq(externalMeetings.projectId, projectId))).orderBy(desc(externalMeetings.startTime));
        } else {
          return await db.select().from(externalMeetings).where(eq(externalMeetings.userId, userId)).orderBy(desc(externalMeetings.startTime));
        }
      }
      async getExternalMeeting(id) {
        const [meeting] = await db.select().from(externalMeetings).where(eq(externalMeetings.id, id));
        return meeting || void 0;
      }
      async getExternalMeetingByExternalId(externalId, userId) {
        const [meeting] = await db.select().from(externalMeetings).where(and(eq(externalMeetings.externalId, externalId), eq(externalMeetings.userId, userId)));
        return meeting || void 0;
      }
      async createExternalMeeting(meeting) {
        const [newMeeting] = await db.insert(externalMeetings).values(meeting).returning();
        return newMeeting;
      }
      async updateExternalMeeting(id, updates) {
        const [meeting] = await db.update(externalMeetings).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(externalMeetings.id, id)).returning();
        return meeting;
      }
      async linkExternalMeetingToProject(externalMeetingId, projectId) {
        const [meeting] = await db.update(externalMeetings).set({ projectId, updatedAt: /* @__PURE__ */ new Date() }).where(eq(externalMeetings.id, externalMeetingId)).returning();
        return meeting;
      }
      async deleteExternalMeeting(id) {
        await db.delete(externalMeetings).where(eq(externalMeetings.id, id));
      }
      async getProjectMembers(projectId) {
        const result = await db.select().from(projectMembers).leftJoin(users, eq(projectMembers.userId, users.id)).where(eq(projectMembers.projectId, projectId));
        return result.map((r) => ({
          ...r.project_members,
          user: r.users
        }));
      }
      async addProjectMember(member) {
        const [newMember] = await db.insert(projectMembers).values(member).returning();
        return newMember;
      }
      async removeProjectMember(projectId, userId) {
        await db.delete(projectMembers).where(
          and(eq(projectMembers.projectId, projectId), eq(projectMembers.userId, userId))
        );
      }
      async getNotifications(userId) {
        return await db.select().from(notifications).where(eq(notifications.userId, userId)).orderBy(desc(notifications.createdAt)).limit(50);
      }
      async createNotification(notification) {
        const [newNotification] = await db.insert(notifications).values(notification).returning();
        return newNotification;
      }
      async markNotificationRead(id) {
        await db.update(notifications).set({ read: true }).where(eq(notifications.id, id));
      }
      async getUserSettings(userId) {
        const [settings] = await db.select().from(userSettings).where(eq(userSettings.userId, userId));
        return settings || void 0;
      }
      async createUserSettings(data) {
        const [settings] = await db.insert(userSettings).values(data).returning();
        return settings;
      }
      async updateUserSettings(userId, settings) {
        const existing = await this.getUserSettings(userId);
        if (existing) {
          const [updated] = await db.update(userSettings).set({ ...settings, updatedAt: /* @__PURE__ */ new Date() }).where(eq(userSettings.userId, userId)).returning();
          return updated;
        } else {
          const [created] = await db.insert(userSettings).values({ userId, ...settings }).returning();
          return created;
        }
      }
      async getDashboardStats(userId) {
        const [projectsResult, activeTasksResult, completedTasksResult] = await Promise.all([
          // Get total projects count
          db.select({ count: count() }).from(projects).leftJoin(projectMembers, eq(projects.id, projectMembers.projectId)).where(or(eq(projects.ownerId, userId), eq(projectMembers.userId, userId))),
          // Get active tasks count
          db.select({ count: count() }).from(tasks).where(
            and(
              eq(tasks.assigneeId, userId),
              or(eq(tasks.status, "todo"), eq(tasks.status, "in_progress"))
            )
          ),
          // Get completed tasks count
          db.select({ count: count() }).from(tasks).where(
            and(
              eq(tasks.assigneeId, userId),
              eq(tasks.status, "completed")
            )
          )
        ]);
        const userProjectIds = await db.select({ projectId: projects.id }).from(projects).leftJoin(projectMembers, eq(projects.id, projectMembers.projectId)).where(or(eq(projects.ownerId, userId), eq(projectMembers.userId, userId)));
        const projectIds = userProjectIds.map((p) => p.projectId);
        let teamMemberCount = 0;
        if (projectIds.length > 0) {
          const uniqueMembers = await db.selectDistinct({ userId: projectMembers.userId }).from(projectMembers).where(inArray(projectMembers.projectId, projectIds));
          const projectOwners = await db.selectDistinct({ ownerId: projects.ownerId }).from(projects).where(inArray(projects.id, projectIds));
          const allMemberIds = /* @__PURE__ */ new Set([
            ...uniqueMembers.map((m) => m.userId).filter(Boolean),
            ...projectOwners.map((o) => o.ownerId).filter(Boolean)
          ]);
          teamMemberCount = allMemberIds.size;
        }
        return {
          totalProjects: projectsResult[0]?.count || 0,
          activeTasks: activeTasksResult[0]?.count || 0,
          completedTasks: completedTasksResult[0]?.count || 0,
          teamMembers: teamMemberCount
        };
      }
      async getRecentActivity(userId, limit = 10) {
        const activities = [];
        const userProjects = await db.select({ id: projects.id }).from(projects).leftJoin(projectMembers, eq(projects.id, projectMembers.projectId)).where(or(eq(projects.ownerId, userId), eq(projectMembers.userId, userId)));
        const projectIds = userProjects.map((p) => p.id);
        if (projectIds.length === 0) {
          return [];
        }
        const recentProjects = await db.select({
          id: projects.id,
          name: projects.name,
          createdAt: projects.createdAt,
          ownerId: projects.ownerId
        }).from(projects).leftJoin(projectMembers, eq(projects.id, projectMembers.projectId)).where(or(eq(projects.ownerId, userId), eq(projectMembers.userId, userId))).orderBy(desc(projects.createdAt)).limit(5);
        for (const project of recentProjects) {
          const owner = await this.getUser(project.ownerId);
          activities.push({
            id: `project_${project.id}`,
            type: "created",
            user: owner?.name || "Someone",
            action: "created project",
            target: project.name,
            time: project.createdAt,
            createdAt: project.createdAt
          });
        }
        const recentTasks = await db.select({
          id: tasks.id,
          title: tasks.title,
          status: tasks.status,
          updatedAt: tasks.updatedAt,
          assigneeId: tasks.assigneeId,
          projectId: tasks.projectId
        }).from(tasks).where(sql2`${tasks.projectId} IN (${sql2.join(projectIds.map((id) => sql2`${id}`), sql2`, `)})`).orderBy(desc(tasks.updatedAt)).limit(5);
        for (const task of recentTasks) {
          const assignee = task.assigneeId ? await this.getUser(task.assigneeId) : null;
          const action = task.status === "completed" ? "completed task" : "updated task";
          const type = task.status === "completed" ? "completed" : "updated";
          activities.push({
            id: `task_${task.id}`,
            type,
            user: assignee?.name || "Someone",
            action,
            target: task.title,
            time: task.updatedAt,
            createdAt: task.updatedAt
          });
        }
        const recentMeetings = await db.select({
          id: meetings.id,
          title: meetings.title,
          createdAt: meetings.createdAt,
          createdById: meetings.createdById
        }).from(meetings).where(sql2`${meetings.projectId} IN (${sql2.join(projectIds.map((id) => sql2`${id}`), sql2`, `)})`).orderBy(desc(meetings.createdAt)).limit(3);
        for (const meeting of recentMeetings) {
          const creator = await this.getUser(meeting.createdById);
          activities.push({
            id: `meeting_${meeting.id}`,
            type: "ai",
            user: creator?.name || "Someone",
            action: "recorded meeting",
            target: meeting.title,
            time: meeting.createdAt,
            createdAt: meeting.createdAt
          });
        }
        return activities.sort((a, b) => new Date(b.time).getTime() - new Date(a.time).getTime()).slice(0, limit);
      }
      async getTodaysMeetings(userId) {
        const today = /* @__PURE__ */ new Date();
        const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1);
        const userProjects = await db.select({ id: projects.id }).from(projects).leftJoin(projectMembers, eq(projects.id, projectMembers.projectId)).where(or(eq(projects.ownerId, userId), eq(projectMembers.userId, userId)));
        const projectIds = userProjects.map((p) => p.id);
        if (projectIds.length === 0) {
          return [];
        }
        const todaysMeetings = await db.select({
          meeting: meetings,
          projectName: projects.name,
          creatorName: users.name
        }).from(meetings).leftJoin(projects, eq(meetings.projectId, projects.id)).leftJoin(users, eq(meetings.createdById, users.id)).where(
          and(
            sql2`${meetings.projectId} IN (${sql2.join(projectIds.map((id) => sql2`${id}`), sql2`, `)})`,
            gte(meetings.scheduledAt, startOfDay),
            lt(meetings.scheduledAt, endOfDay)
          )
        ).orderBy(asc(meetings.scheduledAt));
        return todaysMeetings.map((row) => ({
          ...row.meeting,
          project: row.projectName ? { name: row.projectName } : void 0,
          creator: { name: row.creatorName || "Unknown" }
        }));
      }
      // Invitation methods
      async createInvitation(invitation) {
        const [newInvitation] = await db.insert(invitations).values(invitation).returning();
        return newInvitation;
      }
      async getInvitation(token) {
        const [result] = await db.select({
          invitation: invitations,
          project: projects,
          inviter: users
        }).from(invitations).leftJoin(projects, eq(invitations.projectId, projects.id)).leftJoin(users, eq(invitations.inviterUserId, users.id)).where(eq(invitations.token, token));
        if (!result || !result.project || !result.inviter) {
          return void 0;
        }
        return {
          ...result.invitation,
          project: result.project,
          inviter: result.inviter
        };
      }
      async getInvitationsByEmail(email) {
        const results = await db.select({
          invitation: invitations,
          project: projects,
          inviter: users
        }).from(invitations).leftJoin(projects, eq(invitations.projectId, projects.id)).leftJoin(users, eq(invitations.inviterUserId, users.id)).where(eq(invitations.inviteeEmail, email)).orderBy(desc(invitations.createdAt));
        return results.filter((r) => r.project && r.inviter).map((r) => ({
          ...r.invitation,
          project: r.project,
          inviter: r.inviter
        }));
      }
      async getInvitationsByProject(projectId) {
        const results = await db.select({
          invitation: invitations,
          inviter: users
        }).from(invitations).leftJoin(users, eq(invitations.inviterUserId, users.id)).where(eq(invitations.projectId, projectId)).orderBy(desc(invitations.createdAt));
        return results.filter((r) => r.inviter).map((r) => ({
          ...r.invitation,
          inviter: r.inviter
        }));
      }
      async updateInvitation(token, updates) {
        const [invitation] = await db.update(invitations).set(updates).where(eq(invitations.token, token)).returning();
        return invitation;
      }
      async deleteInvitation(token) {
        await db.delete(invitations).where(eq(invitations.token, token));
      }
      async cleanupExpiredInvitations() {
        await db.delete(invitations).where(lt(invitations.expiresAt, /* @__PURE__ */ new Date()));
      }
      // WebAuthn Authenticator methods
      async getUserAuthenticators(userId) {
        return await db.select().from(authenticators).where(eq(authenticators.userId, userId));
      }
      async getAuthenticatorByCredentialId(credentialId) {
        const [authenticator] = await db.select().from(authenticators).where(eq(authenticators.credentialId, credentialId));
        return authenticator || void 0;
      }
      async createAuthenticator(authenticator) {
        const [newAuthenticator] = await db.insert(authenticators).values(authenticator).returning();
        return newAuthenticator;
      }
      async updateAuthenticator(credentialId, updates) {
        const [updatedAuthenticator] = await db.update(authenticators).set({ ...updates, lastUsedAt: /* @__PURE__ */ new Date() }).where(eq(authenticators.credentialId, credentialId)).returning();
        return updatedAuthenticator;
      }
      async deleteAuthenticator(credentialId) {
        await db.delete(authenticators).where(eq(authenticators.credentialId, credentialId));
      }
      // Login Events for Security Analytics
      async createLoginEvent(event) {
        const [newEvent] = await db.insert(loginEvents).values(event).returning();
        return newEvent;
      }
      async getLoginEvents(userId, limit = 50) {
        return await db.select().from(loginEvents).where(eq(loginEvents.userId, userId)).orderBy(desc(loginEvents.createdAt)).limit(limit);
      }
      async getLoginEventsByDateRange(userId, startDate, endDate) {
        return await db.select().from(loginEvents).where(and(
          eq(loginEvents.userId, userId),
          gte(loginEvents.createdAt, startDate),
          lt(loginEvents.createdAt, endDate)
        )).orderBy(desc(loginEvents.createdAt));
      }
      async getSecurityAnalytics(userId) {
        const thirtyDaysAgo = /* @__PURE__ */ new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const allEvents = await this.getLoginEventsByDateRange(userId, thirtyDaysAgo, /* @__PURE__ */ new Date());
        const successfulLogins = allEvents.filter((e) => e.type === "login_success" || e.type === "biometric_login");
        const failedLogins = allEvents.filter((e) => e.type === "login_failure" || e.type === "biometric_failure");
        const totalLogins = successfulLogins.length;
        const biometricLogins = successfulLogins.filter((e) => e.method === "biometric").length;
        const passwordLogins = successfulLogins.filter((e) => e.method === "password").length;
        const failedAttempts = failedLogins.length;
        const uniqueDevices = new Set(successfulLogins.filter((e) => e.deviceName).map((e) => e.deviceName)).size;
        const lastLogin = successfulLogins.length > 0 ? successfulLogins[0].createdAt : null;
        const sessionsWithDuration = allEvents.filter((e) => e.sessionDuration && e.sessionDuration > 0);
        const averageSessionDuration = sessionsWithDuration.length > 0 ? Math.round(sessionsWithDuration.reduce((sum, e) => sum + (e.sessionDuration || 0), 0) / sessionsWithDuration.length) : 0;
        const frequencyMap = /* @__PURE__ */ new Map();
        successfulLogins.forEach((event) => {
          if (!event.createdAt) return;
          const date = event.createdAt.toISOString().split("T")[0];
          if (!frequencyMap.has(date)) {
            frequencyMap.set(date, { password: 0, biometric: 0 });
          }
          const dayData = frequencyMap.get(date);
          if (event.method === "biometric") {
            dayData.biometric++;
          } else {
            dayData.password++;
          }
        });
        const loginFrequency = [];
        frequencyMap.forEach((counts, date) => {
          if (counts.password > 0) {
            loginFrequency.push({ date, count: counts.password, method: "password" });
          }
          if (counts.biometric > 0) {
            loginFrequency.push({ date, count: counts.biometric, method: "biometric" });
          }
        });
        const deviceMap = /* @__PURE__ */ new Map();
        successfulLogins.forEach((event) => {
          if (event.deviceName && event.createdAt) {
            if (!deviceMap.has(event.deviceName)) {
              deviceMap.set(event.deviceName, { count: 0, lastUsed: event.createdAt });
            }
            const deviceData = deviceMap.get(event.deviceName);
            deviceData.count++;
            if (event.createdAt > deviceData.lastUsed) {
              deviceData.lastUsed = event.createdAt;
            }
          }
        });
        const deviceBreakdown = Array.from(deviceMap.entries()).map(([deviceName, data]) => ({
          deviceName,
          count: data.count,
          lastUsed: data.lastUsed
        }));
        const recentEvents = allEvents.slice(0, 10);
        return {
          totalLogins,
          biometricLogins,
          passwordLogins,
          failedAttempts,
          uniqueDevices,
          lastLogin,
          averageSessionDuration,
          loginFrequency: loginFrequency.sort((a, b) => a.date.localeCompare(b.date)),
          deviceBreakdown: deviceBreakdown.sort((a, b) => b.lastUsed.getTime() - a.lastUsed.getTime()),
          recentEvents
        };
      }
      // Calculate and update project progress based on completed tasks
      async updateProjectProgress(projectId) {
        try {
          const projectTasks = await this.getTasksByProject(projectId);
          if (projectTasks.length === 0) {
            await db.update(projects).set({ progress: 0, updatedAt: /* @__PURE__ */ new Date() }).where(eq(projects.id, projectId));
            return;
          }
          const completedTasks = projectTasks.filter((task) => task.status === "completed").length;
          const progressPercentage = Math.round(completedTasks / projectTasks.length * 100);
          await db.update(projects).set({ progress: progressPercentage, updatedAt: /* @__PURE__ */ new Date() }).where(eq(projects.id, projectId));
          console.log(`Updated project ${projectId} progress: ${completedTasks}/${projectTasks.length} tasks = ${progressPercentage}%`);
        } catch (error) {
          console.error(`Failed to update project progress for ${projectId}:`, error);
        }
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/services/transcription.ts
var transcription_exports = {};
__export(transcription_exports, {
  transcriptionService: () => transcriptionService
});
var TranscriptionService, transcriptionService;
var init_transcription = __esm({
  "server/services/transcription.ts"() {
    "use strict";
    TranscriptionService = class {
      assemblyAI = {
        apiKey: process.env.ASSEMBLYAI_API_KEY,
        baseUrl: "https://api.assemblyai.com/v2"
      };
      async transcribeAudio(audioDataBase64) {
        try {
          if (this.assemblyAI.apiKey) {
            console.log("Using AssemblyAI for professional mobile transcription...");
            return await this.transcribeWithAssemblyAI(audioDataBase64);
          }
          if (process.env.OPENAI_API_KEY) {
            console.log("AssemblyAI not configured, falling back to OpenAI Whisper...");
            return await this.transcribeWithOpenAI(audioDataBase64);
          }
          throw new Error("No transcription service configured. Please provide ASSEMBLYAI_API_KEY (recommended) or OPENAI_API_KEY to process voice recordings.");
        } catch (error) {
          console.error("Transcription service error:", error);
          if (this.assemblyAI.apiKey && process.env.OPENAI_API_KEY && !error.message.includes("OpenAI")) {
            console.log("AssemblyAI failed, attempting OpenAI Whisper fallback...");
            try {
              return await this.transcribeWithOpenAI(audioDataBase64);
            } catch (openaiError) {
              console.error("OpenAI Whisper fallback also failed:", openaiError);
              throw new Error("Both transcription services failed. Please check your API keys and try again.");
            }
          }
          throw new Error("Voice transcription failed. Please ensure you have valid API keys and try again.");
        }
      }
      async transcribeWithAssemblyAI(audioDataBase64) {
        const audioBuffer = Buffer.from(audioDataBase64, "base64");
        console.log(`Processing audio file: ${Math.round(audioBuffer.length / 1024 / 1024 * 100) / 100} MB`);
        if (audioBuffer.length > 50 * 1024 * 1024) {
          throw new Error("Audio file too large. Maximum size is 50MB. Please record shorter sessions.");
        }
        const uploadResponse = await fetch(`${this.assemblyAI.baseUrl}/upload`, {
          method: "POST",
          headers: {
            "Authorization": this.assemblyAI.apiKey,
            "Content-Type": "application/octet-stream"
          },
          body: audioBuffer
        });
        if (!uploadResponse.ok) {
          throw new Error(`AssemblyAI upload failed: ${uploadResponse.statusText}`);
        }
        const { upload_url } = await uploadResponse.json();
        const transcriptResponse = await fetch(`${this.assemblyAI.baseUrl}/transcript`, {
          method: "POST",
          headers: {
            "Authorization": this.assemblyAI.apiKey,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            audio_url: upload_url,
            // Simplified settings - basic transcription only
            speaker_labels: true,
            // Essential for meetings
            punctuate: true,
            // Essential for readability
            format_text: true,
            // Format properly
            language_code: "en_us"
            // Explicit language instead of detection
          })
        });
        if (!transcriptResponse.ok) {
          const errorDetails = await transcriptResponse.text();
          console.error("AssemblyAI transcription error details:", errorDetails);
          throw new Error(`AssemblyAI transcription request failed: ${transcriptResponse.statusText} - ${errorDetails}`);
        }
        const transcript = await transcriptResponse.json();
        const result = await this.pollForCompletion(transcript.id);
        return {
          text: result.text,
          speakers: result.utterances?.map((utterance) => ({
            speaker: `Speaker ${utterance.speaker}`,
            text: utterance.text,
            confidence: utterance.confidence
          })) || [],
          chapters: result.chapters?.map((chapter) => ({
            start: chapter.start,
            end: chapter.end,
            summary: chapter.summary
          })) || [],
          highlights: result.auto_highlights_result?.results?.map((highlight) => ({
            text: highlight.text,
            confidence: highlight.rank
          })) || []
        };
      }
      async transcribeWithOpenAI(audioDataBase64) {
        const { default: OpenAI3 } = await import("openai");
        const openai3 = new OpenAI3({ apiKey: process.env.OPENAI_API_KEY });
        try {
          const audioBuffer = Buffer.from(audioDataBase64, "base64");
          const audioFile = new File([audioBuffer], "recording.webm", { type: "audio/webm" });
          const transcription = await openai3.audio.transcriptions.create({
            file: audioFile,
            model: "whisper-1",
            language: "en",
            response_format: "text",
            temperature: 0
          });
          return {
            text: transcription || "No transcription available",
            speakers: [],
            // OpenAI Whisper doesn't provide speaker detection
            chapters: [],
            // OpenAI Whisper doesn't provide chapter detection
            highlights: []
            // OpenAI Whisper doesn't provide highlights
          };
        } catch (error) {
          console.error("OpenAI Whisper transcription error:", error);
          throw new Error("OpenAI Whisper transcription failed. Please check your API key.");
        }
      }
      async pollForCompletion(transcriptId) {
        const maxAttempts = 60;
        let attempts = 0;
        while (attempts < maxAttempts) {
          await new Promise((resolve) => setTimeout(resolve, 5e3));
          const response = await fetch(`${this.assemblyAI.baseUrl}/transcript/${transcriptId}`, {
            headers: {
              "Authorization": this.assemblyAI.apiKey
            }
          });
          const data = await response.json();
          if (data.status === "completed") {
            return data;
          }
          if (data.status === "error") {
            throw new Error(`AssemblyAI error: ${data.error}`);
          }
          attempts++;
          console.log(`AssemblyAI processing... attempt ${attempts}/${maxAttempts}`);
        }
        throw new Error("AssemblyAI transcription timed out");
      }
    };
    transcriptionService = new TranscriptionService();
  }
});

// server/services/ai.ts
var ai_exports = {};
__export(ai_exports, {
  aiService: () => aiService
});
import OpenAI from "openai";
var openai, ASSEMBLYAI_API_KEY, AIService, aiService;
var init_ai = __esm({
  "server/services/ai.ts"() {
    "use strict";
    openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    ASSEMBLYAI_API_KEY = process.env.ASSEMBLYAI_API_KEY;
    AIService = class {
      async transcribeAudioFromBase64(base64Audio) {
        const { transcriptionService: transcriptionService2 } = await Promise.resolve().then(() => (init_transcription(), transcription_exports));
        const result = await transcriptionService2.transcribeAudio(base64Audio);
        return result.text;
      }
      // Legacy method for backwards compatibility
      async transcribeAudio(audioData) {
        return this.transcribeAudioFromBase64(audioData);
      }
      async extractTasksFromText(text2) {
        try {
          const completion = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `You are an expert AI meeting analyst that extracts actionable tasks from meeting transcriptions. 

CURRENT DATE CONTEXT: Today is ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]} (${(/* @__PURE__ */ new Date()).getFullYear()})

INSTRUCTIONS:
- Identify specific, actionable tasks that require completion
- Include deadlines mentioned in the conversation
- Determine appropriate priority levels based on urgency and importance
- Extract assignments to specific people if mentioned
- Look for deliverables, next steps, and follow-up actions
- Ignore general discussion unless it contains specific action items

DATE ASSIGNMENT RULES:
- If a specific deadline is mentioned in the conversation, use that date
- If NO deadline is mentioned for a task, automatically assign a due date 7 days from today
- When people say relative dates like "next week", "end of the month", "by Friday", always interpret these as ${(/* @__PURE__ */ new Date()).getFullYear()} unless they explicitly mention a different year
- "Next week" means the upcoming week in ${(/* @__PURE__ */ new Date()).getFullYear()}
- "End of the month" means the current month in ${(/* @__PURE__ */ new Date()).getFullYear()}
- "By Friday" means the next Friday in ${(/* @__PURE__ */ new Date()).getFullYear()}
- Only use years other than ${(/* @__PURE__ */ new Date()).getFullYear()} if explicitly mentioned (e.g., "by January 2026")

RESPONSE FORMAT: Return a JSON object with a "tasks" array. Each task should have:
- title: Brief, action-oriented task description
- description: More detailed context and requirements
- priority: "low", "medium", "high", or "urgent" based on context
- assignee: Person mentioned (if any), otherwise null
- dueDate: ALWAYS provide a date in YYYY-MM-DD format - either the mentioned deadline or 7 days from today (${new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0]})
- category: "development", "design", "meeting", "research", "review", or "other"

Example response:
{
  "tasks": [
    {
      "title": "Implement user authentication system",
      "description": "Create secure login/logout functionality with password encryption for the mobile app",
      "priority": "high",
      "assignee": "John",
      "dueDate": "${(/* @__PURE__ */ new Date()).getFullYear()}-08-22",
      "category": "development"
    }
  ]
}`
              },
              {
                role: "user",
                content: `Extract actionable tasks from this meeting transcription: ${text2}`
              }
            ]
          });
          const responseText = completion.choices[0].message.content || "{}";
          const jsonMatch = responseText.match(/```(?:json)?\s*(\{[\s\S]*\})\s*```/) || [null, responseText];
          const result = JSON.parse(jsonMatch[1]);
          return result.tasks || [];
        } catch (error) {
          console.error("Task extraction error:", error);
          return this.generateFallbackTasks(text2);
        }
      }
      generateFallbackTasks(text2) {
        const fallbackTasks = [];
        const lowerText = text2.toLowerCase();
        if (lowerText.includes("need to") || lowerText.includes("should")) {
          fallbackTasks.push({
            title: "Follow up on meeting discussion",
            description: "Review and action the items discussed in the meeting",
            priority: "medium"
          });
        }
        if (lowerText.includes("deadline") || lowerText.includes("by next") || lowerText.includes("friday")) {
          fallbackTasks.push({
            title: "Complete deadline-sensitive work",
            description: "Address upcoming deadline mentioned in the meeting",
            priority: "high"
          });
        }
        if (lowerText.includes("review") || lowerText.includes("check")) {
          fallbackTasks.push({
            title: "Review and provide feedback",
            description: "Complete the review items discussed in the meeting",
            priority: "medium"
          });
        }
        return fallbackTasks;
      }
      async generateMeetingSummary(transcription) {
        try {
          const response = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `You are an expert meeting summarizer. Create comprehensive yet concise meeting summaries that capture all critical information.

SUMMARY STRUCTURE:
\u{1F4C5} **Meeting Overview**: Brief meeting purpose and context

\u{1F3AF} **Key Decisions Made**:
- List major decisions and outcomes
- Include any approvals or rejections

\u{1F4CB} **Action Items**:
- Specific tasks with owners and deadlines
- Next steps and follow-ups required

\u{1F4A1} **Important Discussions**:
- Key topics covered
- Concerns raised and addressed
- Ideas or suggestions shared

\u26A0\uFE0F **Risks & Issues**:
- Problems identified
- Potential roadblocks
- Items requiring escalation

\u{1F4C5} **Next Meeting/Follow-up**:
- When to reconvene
- What to prepare for next time

Keep the summary professional, organized, and actionable. Focus on outcomes rather than just discussion points.`
              },
              {
                role: "user",
                content: `Create a comprehensive meeting summary from this transcription: ${transcription}`
              }
            ]
          });
          return response.choices[0].message.content || "No summary generated";
        } catch (error) {
          console.error("Summary generation error:", error);
          return `**Meeting Summary**

The meeting covered important project topics and team discussions. Key points included project progress updates, task assignments, and upcoming deadlines. 

**Action Items:**
- Follow up on discussed items
- Review project timeline
- Schedule next team meeting

**Next Steps:**
Team members to complete assigned tasks and report back on progress.`;
        }
      }
      async generateProjectInsights(project, tasks2) {
        try {
          const now = /* @__PURE__ */ new Date();
          const projectData = {
            name: project.name,
            progress: project.progress,
            status: project.status,
            dueDate: project.dueDate,
            totalTasks: tasks2.length,
            completedTasks: tasks2.filter((t) => t.status === "completed").length,
            inProgressTasks: tasks2.filter((t) => t.status === "in_progress").length,
            overdueTasks: tasks2.filter((t) => t.dueDate && new Date(t.dueDate) < now && t.status !== "completed").length,
            upcomingDeadlines: tasks2.filter((t) => t.dueDate && new Date(t.dueDate) > now && new Date(t.dueDate) <= new Date(now.getTime() + 7 * 24 * 60 * 60 * 1e3)).length,
            highPriorityTasks: tasks2.filter((t) => t.priority === "high" || t.priority === "urgent").length
          };
          const completion = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `You are an expert AI project management consultant with deep expertise in project health analysis, risk assessment, and productivity optimization. Analyze project data comprehensively and provide actionable insights.

Respond with valid JSON in this exact format:
{
  "healthScore": number (0-100, consider completion rate, deadline adherence, task distribution),
  "completionPrediction": string (realistic timeline prediction with specific date if possible),
  "riskFactors": array of strings (specific, actionable risk factors),
  "recommendations": array of strings (specific, actionable recommendations),
  "workloadBalance": {
    "overloaded": array of strings (team members or areas with too much work),
    "underutilized": array of strings (areas that could take on more work)
  }
}

Focus on:
- Realistic health scoring based on actual progress vs time
- Specific deadline predictions
- Actionable risk factors and recommendations
- Workload optimization suggestions`
              },
              {
                role: "user",
                content: `Analyze this project comprehensively: ${JSON.stringify(projectData, null, 2)}`
              }
            ],
            response_format: { type: "json_object" }
          });
          const result = JSON.parse(completion.choices[0].message.content || "{}");
          return {
            healthScore: result.healthScore || 75,
            completionPrediction: result.completionPrediction || "On track for completion",
            riskFactors: result.riskFactors || [],
            recommendations: result.recommendations || [],
            workloadBalance: result.workloadBalance || { overloaded: [], underutilized: [] }
          };
        } catch (error) {
          console.error("Insights generation error:", error);
          const now = /* @__PURE__ */ new Date();
          const completionRate = tasks2.length > 0 ? tasks2.filter((t) => t.status === "completed").length / tasks2.length * 100 : 0;
          const overdueCount = tasks2.filter((t) => t.dueDate && new Date(t.dueDate) < now && t.status !== "completed").length;
          return {
            healthScore: Math.max(20, Math.min(95, Math.round(completionRate - overdueCount * 10 + project.progress * 0.3))),
            completionPrediction: completionRate > 80 ? "On track for timely completion" : completionRate > 50 ? "May need attention to meet deadlines" : "At risk of delays",
            riskFactors: overdueCount > 0 ? [`${overdueCount} overdue tasks need immediate attention`] : [],
            recommendations: completionRate < 50 ? ["Focus on completing high-priority tasks", "Review task assignments and deadlines"] : ["Maintain current progress", "Monitor upcoming deadlines"],
            workloadBalance: { overloaded: [], underutilized: [] }
          };
        }
      }
      async generateSmartNotifications(projects2, tasks2, userId) {
        try {
          const now = /* @__PURE__ */ new Date();
          const notifications2 = [];
          tasks2.forEach((task) => {
            if (task.dueDate && task.status !== "completed") {
              const dueDate = new Date(task.dueDate);
              const daysUntilDue = Math.ceil((dueDate.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24));
              if (daysUntilDue === 1) {
                notifications2.push({
                  id: `deadline_${task.id}_tomorrow`,
                  type: "deadline_alert",
                  priority: task.priority === "urgent" || task.priority === "high" ? "urgent" : "high",
                  title: "Task Due Tomorrow",
                  message: `"${task.title}" is due tomorrow. Priority: ${task.priority}`,
                  actionable: true,
                  data: { taskId: task.id, projectId: task.projectId },
                  createdAt: now
                });
              } else if (daysUntilDue <= 0) {
                notifications2.push({
                  id: `deadline_${task.id}_overdue`,
                  type: "deadline_alert",
                  priority: "urgent",
                  title: "Overdue Task",
                  message: `"${task.title}" was due ${Math.abs(daysUntilDue)} day(s) ago`,
                  actionable: true,
                  data: { taskId: task.id, projectId: task.projectId },
                  createdAt: now
                });
              }
            }
          });
          for (const project of projects2) {
            const projectTasks = tasks2.filter((t) => t.projectId === project.id);
            const insights = await this.generateProjectInsights(project, projectTasks);
            if (insights.healthScore < 60) {
              notifications2.push({
                id: `health_${project.id}`,
                type: "project_health",
                priority: insights.healthScore < 40 ? "urgent" : "high",
                title: "Project Health Alert",
                message: `${project.name} health score is ${insights.healthScore}%. ${insights.riskFactors[0] || "Needs attention"}`,
                actionable: true,
                data: { projectId: project.id, insights },
                createdAt: now
              });
            }
            if (insights.recommendations.length > 0) {
              notifications2.push({
                id: `suggestion_${project.id}`,
                type: "ai_suggestion",
                priority: "medium",
                title: "AI Recommendation",
                message: `For ${project.name}: ${insights.recommendations[0]}`,
                actionable: true,
                data: { projectId: project.id, recommendation: insights.recommendations[0] },
                createdAt: now
              });
            }
          }
          return notifications2;
        } catch (error) {
          console.error("Smart notifications error:", error);
          return [];
        }
      }
      extractRecommendations(briefingMessage) {
        const lines = briefingMessage.split("\n").filter((line) => line.trim().length > 0);
        const recommendations = [];
        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.match(/^\d+\.\s/) || trimmed.match(/^[-]\s/) || trimmed.includes("**") && trimmed.length > 20) {
            recommendations.push(trimmed);
          }
        }
        if (recommendations.length === 0) {
          const sections = briefingMessage.split(/\*\*[^*]+\*\*/).filter((section) => section.trim().length > 50);
          return sections.slice(0, 3);
        }
        return recommendations.slice(0, 5);
      }
      async generateSmartDailyBriefing(projects2, tasks2, userId, userName) {
        try {
          const now = /* @__PURE__ */ new Date();
          const today = now.toISOString().split("T")[0];
          const todayStart = /* @__PURE__ */ new Date(today + "T00:00:00.000Z");
          const completedToday = tasks2.filter(
            (t) => t.status === "completed" && new Date(t.updatedAt) >= todayStart
          ).length;
          const urgentTasks = tasks2.filter(
            (t) => t.status !== "completed" && (t.priority === "urgent" || t.dueDate && new Date(t.dueDate) <= new Date(now.getTime() + 24 * 60 * 60 * 1e3))
          );
          const upcomingDeadlines = tasks2.filter(
            (t) => t.dueDate && new Date(t.dueDate) > now && new Date(t.dueDate) <= new Date(now.getTime() + 7 * 24 * 60 * 60 * 1e3)
          );
          const projectsAtRisk = projects2.filter((project) => {
            const projectTasks = tasks2.filter((t) => t.projectId === project.id);
            const completionRate = projectTasks.length > 0 ? projectTasks.filter((t) => t.status === "completed").length / projectTasks.length * 100 : 100;
            return completionRate < 50 || project.progress < 30;
          });
          const contextualPatterns = await this.analyzeUserPatterns(tasks2, userId);
          const completion = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `You are a proactive AI project assistant creating a one-way email briefing. Create an intelligent daily briefing that:
            
1. Provides a warm, personalized greeting using the user's name${userName ? ` (${userName})` : ""}
2. Highlights urgent priorities and suggests specific actions
3. Identifies patterns and makes context-aware recommendations
4. Offers priority adjustments and suggestions
5. Provides actionable insights, not just status updates

IMPORTANT: This is an EMAIL NOTIFICATION, not an interactive chat. Do NOT ask questions that expect responses like "Would you like me to..." or "Should I..." or "Let me know how you'd like to proceed!"

Instead, provide ACTIONABLE STATEMENTS like:
- "Consider scheduling a code review for..."
- "Priority recommendation: Focus on..."
- "Suggested next step: Coordinate with..."
- "To improve efficiency, tackle these tasks together..."

${userName ? `Start your briefing with "Hello ${userName}," and use their name naturally throughout the message.` : "Start with a personalized greeting."}

Be specific about projects and tasks by name. Focus on being helpful and proactive with concrete recommendations, not questions.`
              },
              {
                role: "user",
                content: `Generate a smart daily briefing:

**Today's Status:**
- ${completedToday} tasks completed today
- ${urgentTasks.length} urgent tasks needing attention: ${urgentTasks.map((t) => t.title).join(", ")}
- ${upcomingDeadlines.length} deadlines this week
- ${projectsAtRisk.length} projects at risk: ${projectsAtRisk.map((p) => p.name).join(", ")}

**User Patterns Detected:**
${contextualPatterns.workingOn ? `- You've been focusing on: ${contextualPatterns.workingOn}` : ""}
${contextualPatterns.suggestions.join("\n")}

**Project Details:**
${projects2.map((p) => `${p.name}: ${p.progress}% complete, ${tasks2.filter((t) => t.projectId === p.id && t.status !== "completed").length} open tasks`).join("\n")}`
              }
            ]
          });
          const briefingMessage = completion.choices[0].message.content || "Good morning! Ready to tackle today's priorities.";
          const productivityScore = Math.min(100, Math.max(
            0,
            completedToday * 15 + (urgentTasks.length === 0 ? 35 : Math.max(0, 35 - urgentTasks.length * 8)) + (upcomingDeadlines.length > 0 ? Math.max(0, 25 - Math.max(0, upcomingDeadlines.length - 3) * 5) : 25) + (projectsAtRisk.length === 0 ? 25 : Math.max(0, 25 - projectsAtRisk.length * 5))
          ));
          const recommendations = this.extractRecommendations(briefingMessage);
          return {
            date: today,
            totalTasks: tasks2.length,
            completedToday,
            upcomingDeadlines: upcomingDeadlines.length,
            activeProjects: projects2.length,
            // FIXED: Add missing active project count
            projectsAtRisk: projectsAtRisk.map((p) => p.name),
            keyRecommendations: recommendations,
            productivityScore,
            urgentTasks: urgentTasks.length,
            contextualSuggestions: contextualPatterns.suggestions,
            smartBriefing: briefingMessage
          };
        } catch (error) {
          console.error("Smart daily briefing error:", error);
          const now = /* @__PURE__ */ new Date();
          return {
            date: now.toISOString().split("T")[0],
            totalTasks: tasks2.length,
            completedToday: 0,
            upcomingDeadlines: 0,
            projectsAtRisk: [],
            keyRecommendations: ["Good morning! Let's review your priorities and tackle today's important tasks."],
            productivityScore: 75,
            urgentTasks: 0,
            contextualSuggestions: [],
            smartBriefing: "Good morning! Ready to make today productive. Let's review your priorities."
          };
        }
      }
      async generateLunchBriefing(projects2, tasks2, userId) {
        try {
          const now = /* @__PURE__ */ new Date();
          const today = now.toISOString().split("T")[0];
          const todayEnd = /* @__PURE__ */ new Date(today + "T23:59:59.999Z");
          const afternoonStart = /* @__PURE__ */ new Date(today + "T14:00:00.000Z");
          const afternoonTasks = tasks2.filter((t) => {
            if (t.dueDate) {
              const taskDue = new Date(t.dueDate);
              return taskDue >= afternoonStart && taskDue <= todayEnd && t.status !== "completed";
            }
            return false;
          });
          const morningProgress = tasks2.filter((t) => {
            const todayMorning = /* @__PURE__ */ new Date(today + "T00:00:00.000Z");
            const noon = /* @__PURE__ */ new Date(today + "T12:00:00.000Z");
            return t.updatedAt >= todayMorning && t.updatedAt <= noon && t.status === "completed";
          });
          const urgentAfternoon = afternoonTasks.filter((t) => t.priority === "urgent" || t.priority === "high");
          const completion = await openai.chat.completions.create({
            messages: [
              {
                role: "system",
                content: `You are an AI assistant providing a one-way email notification for midday check-in and afternoon preview. Be encouraging about morning progress and provide specific, actionable guidance for the afternoon. Keep it focused and motivating.

IMPORTANT: This is an EMAIL NOTIFICATION, not an interactive conversation. Do NOT ask questions that expect responses. Provide clear statements and recommendations instead.`
              },
              {
                role: "user",
                content: `Generate a lunch briefing for midday check-in:

**Morning Progress:**
- ${morningProgress.length} tasks completed this morning
- Current momentum: ${morningProgress.length > 0 ? "Strong" : "Building up"}

**Afternoon Schedule:**
- ${afternoonTasks.length} tasks scheduled for afternoon
- ${urgentAfternoon.length} high-priority items need attention
- Key afternoon tasks: ${afternoonTasks.slice(0, 3).map((t) => t.title).join(", ")}

**Project Status:**
${projects2.map((p) => `${p.name}: ${p.progress}% complete`).join("\n")}

Provide encouraging feedback on morning progress and 2-3 specific recommendations for a productive afternoon.`
              }
            ],
            model: "gpt-4o",
            temperature: 0.7,
            max_tokens: 300
          });
          const briefingContent = completion.choices[0].message.content || "Great work this morning! Let's make the afternoon just as productive.";
          return {
            date: today,
            morningProgress: morningProgress.length,
            afternoonTasks: projects2.length,
            // FIXED: Show active projects count instead of afternoon tasks
            activeProjects: projects2.length,
            // FIXED: Add missing active project count
            urgentAfternoon: urgentAfternoon.length,
            briefingContent,
            upcomingTasks: afternoonTasks.slice(0, 5),
            motivationalNote: morningProgress.length > 0 ? "You're building great momentum!" : "Ready to pick up the pace this afternoon!"
          };
        } catch (error) {
          console.error("Lunch briefing error:", error);
          return {
            date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
            morningProgress: 0,
            afternoonTasks: 0,
            urgentAfternoon: 0,
            briefingContent: "Time for a refreshing lunch break! Your afternoon is ready for productive work.",
            upcomingTasks: [],
            motivationalNote: "You've got this! Take a proper break and come back energized."
          };
        }
      }
      // Legacy method for backward compatibility
      async generateDailySummary(projects2, tasks2, userId) {
        return this.generateSmartDailyBriefing(projects2, tasks2, userId);
      }
      async analyzeUserPatterns(tasks2, userId) {
        try {
          const now = /* @__PURE__ */ new Date();
          const pastWeek = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
          const recentTasks = tasks2.filter((t) => new Date(t.updatedAt) >= pastWeek);
          const recentCompletions = recentTasks.filter((t) => t.status === "completed");
          const stuckTasks = tasks2.filter(
            (t) => t.status === "in_progress" && new Date(t.updatedAt) < new Date(now.getTime() - 3 * 24 * 60 * 60 * 1e3)
          );
          const workAreas = recentTasks.map((t) => {
            if (t.title.toLowerCase().includes("auth") || t.title.toLowerCase().includes("login")) return "authentication";
            if (t.title.toLowerCase().includes("ui") || t.title.toLowerCase().includes("design")) return "user interface";
            if (t.title.toLowerCase().includes("api") || t.title.toLowerCase().includes("backend")) return "backend development";
            if (t.title.toLowerCase().includes("test") || t.title.toLowerCase().includes("bug")) return "testing and debugging";
            return "general development";
          });
          const mostCommonArea = workAreas.reduce(
            (a, b, i, arr) => arr.filter((v) => v === a).length >= arr.filter((v) => v === b).length ? a : b,
            workAreas[0] || "general development"
          );
          const suggestions = [];
          if (stuckTasks.length > 0) {
            suggestions.push(`\u{1F4CB} You have ${stuckTasks.length} tasks stuck in progress for 3+ days. Would you like me to schedule a code review or pair programming session?`);
          }
          if (recentCompletions.length >= 3 && mostCommonArea === "authentication") {
            suggestions.push(`\u{1F680} You've been making great progress on authentication features for 3+ days. Consider scheduling a security review or demo session.`);
          }
          const highPriorityOld = tasks2.filter(
            (t) => (t.priority === "high" || t.priority === "urgent") && t.status !== "completed" && new Date(t.createdAt) < pastWeek
          );
          if (highPriorityOld.length > 0) {
            suggestions.push(`\u26A0\uFE0F You have ${highPriorityOld.length} high-priority tasks from last week. Should I suggest priority adjustments or deadline extensions?`);
          }
          return {
            workingOn: mostCommonArea,
            suggestions
          };
        } catch (error) {
          console.error("Pattern analysis error:", error);
          return {
            workingOn: "general development",
            suggestions: []
          };
        }
      }
      async generateMeetingPreparation(upcomingMeeting, projectId, userId, attendeeEmails = []) {
        try {
          console.log(`\u{1F3AF} MEETING PREP START: projectId=${projectId}, userId=${userId}, meeting=${upcomingMeeting?.title}, attendees=${attendeeEmails.length}`);
          const { storage: storage2 } = await Promise.resolve().then(() => (init_storage(), storage_exports));
          const attendeeUsers = [];
          const attendeeTasks = [];
          if (attendeeEmails.length > 0) {
            console.log(`\u{1F465} ANALYZING ATTENDEES: ${attendeeEmails.join(", ")}`);
            for (const email of attendeeEmails) {
              try {
                const user = await storage2.getUserByEmail(email);
                if (user) {
                  attendeeUsers.push(user);
                  console.log(`\u{1F464} FOUND USER: ${user.name} (${email})`);
                } else {
                  console.log(`\u2753 EXTERNAL ATTENDEE: ${email} (not in system)`);
                }
              } catch (error) {
                console.log(`\u26A0\uFE0F Error looking up attendee ${email}:`, error);
              }
            }
            if (attendeeUsers.length > 0) {
              const effectiveProjectId2 = projectId || (upcomingMeeting.externalId ? (await storage2.getExternalMeetingByExternalId(upcomingMeeting.externalId, userId))?.projectId : null);
              const allUserTasks = await storage2.getTasks(effectiveProjectId2 || "", userId);
              for (const task of allUserTasks) {
                const isAssignedToAttendee = attendeeUsers.some((user) => user.id === task.assigneeId);
                const mentionsAttendee = attendeeUsers.some(
                  (user) => task.title.toLowerCase().includes(user.name.toLowerCase()) || task.description && task.description.toLowerCase().includes(user.name.toLowerCase())
                );
                if (isAssignedToAttendee || mentionsAttendee) {
                  attendeeTasks.push({
                    ...task,
                    relatedAttendee: attendeeUsers.find(
                      (u) => u.id === task.assigneeId || task.title.toLowerCase().includes(u.name.toLowerCase()) || task.description && task.description.toLowerCase().includes(u.name.toLowerCase())
                    )?.name || "Unknown"
                  });
                }
              }
              console.log(`\u{1F4CB} ATTENDEE-RELATED TASKS: Found ${attendeeTasks.length} tasks for ${attendeeUsers.length} attendees`);
            }
          }
          let linkedProject = null;
          if (upcomingMeeting.externalId && !projectId) {
            console.log(`\u{1F50D} CHECKING FOR LINKED PROJECT: external meeting ${upcomingMeeting.externalId}`);
            const externalMeeting = await storage2.getExternalMeetingByExternalId(upcomingMeeting.externalId, userId);
            if (externalMeeting && externalMeeting.projectId) {
              linkedProject = await storage2.getProject(externalMeeting.projectId);
              console.log(`\u{1F3AF} FOUND LINKED PROJECT: ${linkedProject?.name} for meeting "${upcomingMeeting.title}"`);
            }
          }
          const project = projectId ? await storage2.getProject(projectId) : linkedProject;
          const effectiveProjectId = projectId || linkedProject?.id;
          let tasks2 = [];
          let allProjects = [];
          if (effectiveProjectId && project) {
            tasks2 = await storage2.getTasks(effectiveProjectId, userId);
            allProjects = [project];
            console.log(`\u{1F4CB} ${linkedProject ? "Linked" : "Single"} project meeting prep: ${project.name} with ${tasks2.length} tasks`);
          } else if (upcomingMeeting.id === "comprehensive") {
            console.log(`\u{1F50D} COMPREHENSIVE MODE: Getting all projects for cross-project meeting prep: ${userId}`);
            allProjects = await storage2.getProjects(userId);
            console.log(`\u{1F4C1} Found ${allProjects.length} projects for comprehensive analysis`);
            for (const proj of allProjects) {
              const projectTasks = await storage2.getTasks(proj.id, userId);
              console.log(`\u{1F4CB} Project ${proj.name}: ${projectTasks.length} tasks`);
              tasks2.push(...projectTasks.map((t) => ({ ...t, projectName: proj.name })));
            }
            console.log(`\u{1F4CA} COMPREHENSIVE: Total tasks collected: ${tasks2.length}`);
          } else {
            console.log(`\u{1F3AF} MEETING-SPECIFIC MODE: Focusing on "${upcomingMeeting.title}" without project context`);
            tasks2 = [];
            allProjects = [];
            console.log(`\u{1F4CB} Meeting-focused preparation without project data`);
          }
          const recentMeetings = effectiveProjectId ? (await storage2.getMeetings(userId)).filter((m) => m.projectId === effectiveProjectId) : [upcomingMeeting];
          const now = /* @__PURE__ */ new Date();
          const lastWeek = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
          const last3Days = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1e3);
          const nextWeek = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1e3);
          const completed = tasks2.filter((t) => t.status === "completed");
          const recentCompleted = completed.filter((t) => new Date(t.updatedAt) >= lastWeek);
          const todayCompleted = completed.filter((t) => new Date(t.updatedAt) >= last3Days);
          const inProgress = tasks2.filter((t) => t.status === "in_progress");
          const todoTasks = tasks2.filter((t) => t.status === "todo");
          const urgentTasks = tasks2.filter((t) => t.priority === "urgent" && t.status !== "completed");
          const attendeeOverdueTasks = attendeeTasks.filter(
            (t) => t.dueDate && new Date(t.dueDate) < now && t.status !== "completed"
          );
          const attendeeUrgentTasks = attendeeTasks.filter(
            (t) => t.priority === "urgent" && t.status !== "completed"
          );
          const attendeeIncompleteTasks = attendeeTasks.filter(
            (t) => t.status !== "completed"
          );
          console.log(`\u{1F6A8} PRE-MEETING ANALYSIS: ${attendeeOverdueTasks.length} overdue, ${attendeeUrgentTasks.length} urgent, ${attendeeIncompleteTasks.length} incomplete attendee tasks`);
          const highPriorityTasks = tasks2.filter((t) => t.priority === "high" && t.status !== "completed");
          const overdueTasks = tasks2.filter(
            (t) => t.dueDate && new Date(t.dueDate) < now && t.status !== "completed"
          );
          const upcomingDeadlines = tasks2.filter(
            (t) => t.dueDate && new Date(t.dueDate) <= nextWeek && new Date(t.dueDate) >= now && t.status !== "completed"
          );
          const longStandingTodos = todoTasks.filter(
            (t) => new Date(t.createdAt) < lastWeek
          );
          const stalledInProgress = inProgress.filter(
            (t) => new Date(t.updatedAt) < lastWeek
          );
          const completionRate = tasks2.length > 0 ? (completed.length / tasks2.length * 100).toFixed(1) : 0;
          const weeklyVelocity = recentCompleted.length;
          const projectHealth = allProjects.filter((p) => p).map((p) => ({
            name: p.name,
            progress: p.progress || 0,
            dueDate: p.dueDate,
            taskCount: tasks2.filter((t) => t.projectId === p.id).length,
            completedCount: tasks2.filter((t) => t.projectId === p.id && t.status === "completed").length,
            overdueCount: tasks2.filter((t) => t.projectId === p.id && t.dueDate && new Date(t.dueDate) < now && t.status !== "completed").length
          }));
          console.log(`\u{1F916} Generating comprehensive meeting prep: ${tasks2.length} tasks, ${allProjects.length} projects`);
          const completion = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `You are an AI executive assistant creating comprehensive meeting preparation talking points. Generate detailed, actionable content that serves as speaking notes for the user. Include:

\u{1F3AF} **EXECUTIVE SUMMARY** - High-level status in 2-3 bullets
\u2705 **RECENTLY COMPLETED** - What's been accomplished with impact and dates
\u{1F4CA} **PROGRESS METRICS** - Completion rates and velocity trends
\u{1F504} **CURRENT FOCUS** - Active work with ownership and timelines  
\u{1F4C5} **WHAT'S COMING UP** - Immediate priorities and upcoming deadlines
\u26A0\uFE0F **BLOCKERS & DECISIONS** - Issues requiring discussion/approval
\u{1F4A1} **DISCUSSION TOPICS** - Strategic questions and alignment needs
\u{1F6A8} **ESCALATIONS** - Items requiring leadership attention

PRIORITY: Lead with recently completed accomplishments and upcoming priorities. Use specific dates, percentages, and actionable language. Make it scannable with clear sections and bullet points.`
              },
              {
                role: "user",
                content: `Create focused talking points for the specific meeting: "${upcomingMeeting.title || "Meeting"}"${project ? ` in project "${project.name}"` : ""}

**MEETING CONTEXT:**
- Meeting: ${upcomingMeeting.title || "Untitled Meeting"}
- Scheduled: ${new Date(upcomingMeeting.scheduledAt).toLocaleDateString()} at ${new Date(upcomingMeeting.scheduledAt).toLocaleTimeString()}
- Duration: ${upcomingMeeting.duration || "Not specified"} minutes
${project ? `- Project Focus: ${project.name}` : "- Standalone meeting (no project association)"}
${upcomingMeeting.description ? `- Meeting Purpose: ${upcomingMeeting.description}` : ""}

${tasks2.length > 0 ? `**RELEVANT PROJECT STATUS:**
- Total Projects: ${allProjects.length}
- Overall Completion Rate: ${completionRate}%
- Weekly Task Velocity: ${weeklyVelocity} completed
- Active Tasks: ${inProgress.length} in progress, ${todoTasks.length} pending

**PROJECT HEALTH DASHBOARD:**
${projectHealth.map((p) => `\u2022 ${p.name}: ${p.progress}% complete (${p.completedCount}/${p.taskCount} tasks)${p.overdueCount > 0 ? ` \u26A0\uFE0F ${p.overdueCount} overdue` : ""}`).join("\n")}

**\u2705 RECENTLY COMPLETED TASKS (Last 7 Days):**
${recentCompleted.map((t) => `\u2022 \u2705 ${t.title}${t.projectName ? ` (${t.projectName})` : ""} - ${t.priority} priority | Completed: ${new Date(t.updatedAt).toLocaleDateString()}`).join("\n") || "\u2022 No major completions this week"}` : `**MEETING-SPECIFIC PREPARATION:**
This appears to be a standalone meeting not associated with any specific project in your system. 

Focus your preparation on:
- Meeting objectives and agenda
- Key discussion topics for "${upcomingMeeting.title}"
- Expected outcomes and decisions needed
- Action items that may emerge from this discussion

${attendeeEmails.length > 0 ? `**MEETING ATTENDEES (${attendeeEmails.length}):**
${attendeeEmails.map((email) => `\u2022 ${email}`).join("\n")}

**\u{1F465} ATTENDEE ANALYSIS:**
\u2022 Users in system: ${attendeeUsers.length}/${attendeeEmails.length}
\u2022 Tasks related to attendees: ${attendeeTasks.length}` : ""}`}

${attendeeTasks.length > 0 ? `

**\u{1F3AF} PRE-MEETING ACTION ITEMS:**
Items that may come up in discussion with attendees:

**OVERDUE ITEMS AFFECTING ATTENDEES (${attendeeOverdueTasks.length}):**
${attendeeOverdueTasks.map((t) => `\u2022 \u23F0 ${t.title} - Assigned to: ${t.relatedAttendee} | Due: ${new Date(t.dueDate).toLocaleDateString()}`).join("\n") || "\u2022 No overdue attendee tasks"}

**URGENT ATTENDEE TASKS (${attendeeUrgentTasks.length}):**
${attendeeUrgentTasks.map((t) => `\u2022 \u{1F6A8} ${t.title} - ${t.relatedAttendee} | Status: ${t.status}`).join("\n") || "\u2022 No urgent attendee tasks"}

**INCOMPLETE ATTENDEE WORK (${attendeeIncompleteTasks.length}):**
${attendeeIncompleteTasks.map((t) => `\u2022 ${t.status === "in_progress" ? "\u{1F504}" : "\u{1F4DD}"} ${t.title} - ${t.relatedAttendee} | ${t.priority} priority`).join("\n") || "\u2022 All attendee tasks completed"}

**\u{1F4A1} SUGGESTED DISCUSSION POINTS:**
${attendeeOverdueTasks.length > 0 ? "\u2022 Address overdue items and blockers preventing completion" : ""}
${attendeeUrgentTasks.length > 0 ? "\u2022 Review urgent tasks and resource allocation needs" : ""}
${attendeeIncompleteTasks.length > 0 ? "\u2022 Coordinate on active work and dependencies" : ""}
${attendeeIncompleteTasks.length === 0 ? "\u2022 Celebrate completed work and plan next steps" : ""}` : ""}

${tasks2.length > 0 ? `

**\u{1F4C8} COMPLETION METRICS:**
\u2022 Tasks completed this week: ${weeklyVelocity}
\u2022 Overall completion rate: ${completionRate}%
\u2022 Last 3 days: ${todayCompleted.length} tasks finished

**CURRENTLY IN PROGRESS:**
${inProgress.map((t) => `\u2022 \u{1F504} ${t.title}${t.projectName ? ` (${t.projectName})` : ""} - ${t.priority} priority${t.dueDate ? ` | Due: ${new Date(t.dueDate).toLocaleDateString()}` : ""}`).join("\n") || "\u2022 No active work items"}

**CRITICAL ATTENTION NEEDED:**
Urgent Tasks (${urgentTasks.length}):
${urgentTasks.map((t) => `\u2022 \u{1F6A8} ${t.title}${t.projectName ? ` (${t.projectName})` : ""}`).join("\n") || "\u2022 No urgent items"}

Overdue Items (${overdueTasks.length}):
${overdueTasks.map((t) => `\u2022 \u23F0 ${t.title} - Due: ${new Date(t.dueDate).toLocaleDateString()}${t.projectName ? ` (${t.projectName})` : ""}`).join("\n") || "\u2022 No overdue items"}

**\u{1F4C5} WHAT'S COMING UP (Next 7 Days):**
${upcomingDeadlines.map((t) => `\u2022 \u{1F4C5} ${t.title} - Due: ${new Date(t.dueDate).toLocaleDateString()}${t.projectName ? ` (${t.projectName})` : ""} | Status: ${t.status} | Priority: ${t.priority}`).join("\n") || "\u2022 No immediate deadlines"}

**\u{1F4CB} ALL INCOMPLETE TASKS:**
${[...inProgress, ...todoTasks].map((t) => `\u2022 ${t.status === "in_progress" ? "\u{1F504}" : "\u{1F4DD}"} ${t.title}${t.projectName ? ` (${t.projectName})` : ""} - ${t.priority} priority | Status: ${t.status}${t.dueDate ? ` | Due: ${new Date(t.dueDate).toLocaleDateString()}` : ""}`).join("\n") || "\u2022 All tasks completed! \u{1F389}"}

**\u{1F3AF} IMMEDIATE NEXT ACTIONS:**
${todoTasks.filter((t) => t.priority === "high" || t.priority === "urgent").slice(0, 5).map((t) => `\u2022 ${t.title}${t.projectName ? ` (${t.projectName})` : ""} - ${t.priority} priority`).join("\n") || "\u2022 No high-priority items in queue"}

**POTENTIAL BLOCKERS & DECISION POINTS:**
Stalled Items (${stalledInProgress.length + longStandingTodos.length}):
${stalledInProgress.map((t) => `\u2022 \u{1F6D1} ${t.title} - No progress for 7+ days${t.projectName ? ` (${t.projectName})` : ""}`).join("\n")}
${longStandingTodos.map((t) => `\u2022 \u23F8\uFE0F ${t.title} - Pending for 7+ days${t.projectName ? ` (${t.projectName})` : ""}`).join("\n")}

**HIGH-PRIORITY QUEUE:**
${highPriorityTasks.map((t) => `\u2022 \u{1F525} ${t.title}${t.projectName ? ` (${t.projectName})` : ""} - ${t.status}`).join("\n") || "\u2022 No high-priority items in queue"}` : ""}

Meeting Type Context: ${upcomingMeeting.title?.toLowerCase().includes("summit") ? "Strategic planning session" : upcomingMeeting.title?.toLowerCase().includes("brainstorm") ? "Creative ideation session" : upcomingMeeting.title?.toLowerCase().includes("round table") ? "Team alignment meeting" : upcomingMeeting.title?.toLowerCase().includes("weekly") ? "Regular status update" : "General business meeting"}`
              }
            ]
          });
          const result = completion.choices[0].message.content;
          console.log(`\u{1F389} AI generated comprehensive meeting prep: ${result ? "SUCCESS" : "EMPTY"}`);
          console.log(`\u2705 Preparation generated successfully, length: ${result?.length || 0}`);
          if (!result || result.trim().length === 0) {
            return "**\u{1F4CB} No Active Projects or Tasks Found**\n\nIt looks like you don't have any active projects or tasks in the system yet. Once you add some projects and tasks, this comprehensive meeting prep will provide detailed talking points covering:\n\n\u2022 Project progress and completion rates\n\u2022 Recent accomplishments and upcoming deadlines\n\u2022 Priority tasks and potential blockers\n\u2022 Strategic discussion topics\n\nStart by creating your first project to unlock the full power of AI-driven meeting preparation!";
          }
          return result;
        } catch (error) {
          console.error("Meeting preparation error:", error);
          return "**Meeting Preparation Summary**\n\nComprehensive project status ready for discussion. Focus on recent wins, current priorities, and strategic decisions needed.";
        }
      }
      // Voice Assistant Methods
      async processVoiceCommand(command, context) {
        try {
          const completion = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `You are an intelligent project management voice assistant. Process user voice commands and provide helpful responses.

COMMAND TYPES:
1. INFORMATION: Answer questions about projects, tasks, deadlines
2. ACTIONS: Create tasks, update status, set priorities
3. INSIGHTS: Provide analytics, recommendations, summaries
4. NAVIGATION: Guide users to relevant features

RESPONSE FORMAT: Return JSON with:
{
  "action": "information|create_task|update_task|briefing|navigation",
  "response": "Natural language response to speak back to user",
  "dataModified": false,
  "data": { task/project data if action taken }
}

VOICE GUIDELINES:
- Keep responses conversational and concise
- Use natural speech patterns
- Confirm actions clearly
- Provide helpful context

CURRENT CONTEXT:
- User has ${context.projects.length} projects: ${context.projects.map((p) => `"${p.name}" (${p.progress}% complete, status: ${p.status})`).join(", ") || "none"}
- User has ${context.tasks.length} total tasks:
  ${context.tasks.filter((t) => t.status !== "completed").slice(0, 10).map((t) => `"${t.title}" (${t.status}, priority: ${t.priority}${t.dueDate ? `, due: ${new Date(t.dueDate).toLocaleDateString()}` : ""}${t.projectId ? `, project: ${context.projects.find((p) => p.id === t.projectId)?.name || "Unknown"}` : ""})`).join("\n  ") || "none"}
- Completed tasks: ${context.tasks.filter((t) => t.status === "completed").length}
- Current time: ${context.timestamp.toLocaleString()}

When answering questions about "which project" or "what tasks", use the SPECIFIC project names and task titles from above. Be helpful and specific, not generic.

CONVERSATION HISTORY:
${context.conversationHistory.slice(-3).map((h) => `User: ${h.user}
AI: ${h.ai}`).join("\n\n")}

IMPORTANT: Remember the conversation context and provide continuous, intelligent responses that build on previous exchanges.`
              },
              {
                role: "user",
                content: `Process this voice command: "${command}"`
              }
            ]
          });
          const responseText = completion.choices[0].message.content || "{}";
          console.log("\u{1F916} Raw AI response:", responseText);
          let result;
          try {
            result = JSON.parse(responseText);
          } catch (e1) {
            const jsonMatch = responseText.match(/```(?:json)?\s*(\{[\s\S]*\})\s*```/);
            if (jsonMatch && jsonMatch[1]) {
              try {
                result = JSON.parse(jsonMatch[1]);
              } catch (e2) {
                console.error("JSON parsing failed:", e2);
                return {
                  action: "information",
                  response: responseText || "I can help you with your projects. Could you rephrase your question?",
                  dataModified: false,
                  data: null
                };
              }
            } else {
              return {
                action: "information",
                response: responseText || "I can help you with your projects. What would you like to know?",
                dataModified: false,
                data: null
              };
            }
          }
          if (result.action === "create_task" && result.data?.title) {
            const { storage: storage2 } = await Promise.resolve().then(() => (init_storage(), storage_exports));
            const newTask = await storage2.createTask({
              title: result.data.title,
              description: result.data.description || "",
              priority: result.data.priority || "medium",
              status: "todo",
              projectId: result.data.projectId || null,
              dueDate: result.data.dueDate || null,
              assigneeId: context.userId
            });
            result.dataModified = true;
            result.data = newTask;
          }
          if (result.action === "update_task" && result.data?.taskId) {
            const { storage: storage2 } = await Promise.resolve().then(() => (init_storage(), storage_exports));
            const currentTask = await storage2.getTask(result.data.taskId);
            if (!currentTask || currentTask.assigneeId !== context.userId) {
              result.response = "Sorry, I couldn't find that task or you don't have permission to update it.";
              return result;
            }
            const updateData = {};
            if (result.data.title !== void 0) updateData.title = result.data.title;
            if (result.data.description !== void 0) updateData.description = result.data.description;
            if (result.data.status !== void 0) updateData.status = result.data.status;
            if (result.data.priority !== void 0) updateData.priority = result.data.priority;
            if (result.data.dueDate !== void 0) updateData.dueDate = result.data.dueDate;
            if (result.data.projectId !== void 0) updateData.projectId = result.data.projectId;
            const updatedTask = await storage2.updateTask(result.data.taskId, updateData);
            result.dataModified = true;
            result.data = updatedTask;
          }
          return result;
        } catch (error) {
          console.error("Voice command processing error:", error);
          return {
            action: "error",
            response: "Sorry, I'm having trouble processing voice commands right now. Please try again later.",
            dataModified: false,
            data: null
          };
        }
      }
      async generateVoiceBriefing(projects2, tasks2, userId) {
        try {
          const today = /* @__PURE__ */ new Date();
          const todayTasks = tasks2.filter((t) => t.dueDate && new Date(t.dueDate).toDateString() === today.toDateString());
          const overdueTasks = tasks2.filter((t) => t.dueDate && new Date(t.dueDate) < today && t.status !== "completed");
          const urgentTasks = tasks2.filter((t) => t.priority === "urgent" && t.status !== "completed");
          const completion = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `Generate a daily voice briefing for a project manager. Make it conversational and actionable.

BRIEFING STRUCTURE:
- Quick status overview 
- Today's priorities
- Urgent attention items
- Positive productivity insights
- Actionable next steps

VOICE STYLE:
- Professional but friendly
- Natural speech patterns
- Encouraging tone
- Specific and actionable

Return JSON with:
{
  "text": "Detailed written briefing",
  "spokenText": "Conversational version optimized for voice",
  "keyPoints": ["Point 1", "Point 2"],
  "urgentItems": ["Urgent item 1"]
}`
              },
              {
                role: "user",
                content: `Generate briefing for user with:
- ${projects2.length} projects
- ${tasks2.length} total tasks
- ${todayTasks.length} due today
- ${overdueTasks.length} overdue
- ${urgentTasks.length} urgent tasks`
              }
            ]
          });
          const responseText = completion.choices[0].message.content || "{}";
          const jsonMatch = responseText.match(/```(?:json)?\s*(\{[\s\S]*\})\s*```/) || [null, responseText];
          try {
            return JSON.parse(jsonMatch[1]);
          } catch (parseError) {
            return {
              text: "Good morning! You have several projects in progress and tasks to focus on today.",
              spokenText: "Good morning! You have several projects in progress and tasks to focus on today. Would you like me to help you prioritize your work?",
              keyPoints: ["Review project status", "Check urgent tasks"],
              urgentItems: urgentTasks.slice(0, 3).map((t) => t.title)
            };
          }
        } catch (error) {
          console.error("Voice briefing generation error:", error);
          return {
            text: "Unable to generate briefing at this time.",
            spokenText: "I'm having trouble generating your briefing right now. Would you like me to try again?",
            keyPoints: [],
            urgentItems: []
          };
        }
      }
      async processSmartQuery(query, context) {
        try {
          const completion = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `You are an intelligent project management assistant that answers questions about user's work.

QUERY TYPES:
- Status questions: "How are my projects doing?"
- Priority questions: "What should I work on?"
- Analytics: "How productive was I this week?"
- Planning: "When should I schedule this meeting?"

RESPONSE FORMAT: Return JSON with:
{
  "answer": "Detailed written answer",
  "spokenAnswer": "Conversational voice response",
  "data": { relevant data objects },
  "suggestions": ["Action 1", "Action 2"]
}

Be conversational, specific, and helpful.`
              },
              {
                role: "user",
                content: `Answer this query: "${query}"
            
Context:
- ${context.projects.length} projects  
- ${context.tasks.length} tasks
- Recent activity: ${JSON.stringify(context.context)}`
              }
            ]
          });
          const responseText = completion.choices[0].message.content || "{}";
          const jsonMatch = responseText.match(/```(?:json)?\s*(\{[\s\S]*\})\s*```/) || [null, responseText];
          try {
            return JSON.parse(jsonMatch[1]);
          } catch (parseError) {
            return {
              answer: "I can help you with project information, but I'm having trouble processing your specific query right now.",
              spokenAnswer: "I can help you with project information, but I'm having trouble processing your specific query right now. Could you try rephrasing your question?",
              data: {},
              suggestions: ["Try asking about your urgent tasks", "Ask for today's priorities"]
            };
          }
        } catch (error) {
          console.error("Smart query processing error:", error);
          return {
            answer: "Unable to process query at this time.",
            spokenAnswer: "Sorry, I'm having trouble processing queries right now. Please try again later.",
            data: {},
            suggestions: []
          };
        }
      }
      async generateProjectMeetingPreparation(projectId, userId) {
        try {
          console.log(`\u{1F3AF} Starting project-specific meeting preparation for project: ${projectId}`);
          const { storage: storage2 } = await Promise.resolve().then(() => (init_storage(), storage_exports));
          const project = await storage2.getProject(projectId);
          if (!project) {
            throw new Error("Project not found");
          }
          const projectTasks = await storage2.getTasks(projectId, userId);
          console.log(`\u{1F4CB} Project data: ${project.name} with ${projectTasks.length} tasks`);
          const completedTasks = projectTasks.filter((task) => task.status === "completed");
          const inProgressTasks = projectTasks.filter((task) => task.status === "in_progress");
          const todoTasks = projectTasks.filter((task) => task.status === "todo");
          const highPriorityTasks = projectTasks.filter((task) => task.priority === "high" || task.priority === "urgent");
          const overdueTasks = projectTasks.filter(
            (task) => task.dueDate && new Date(task.dueDate) < /* @__PURE__ */ new Date() && task.status !== "completed"
          );
          const progressPercentage = projectTasks.length > 0 ? Math.round(completedTasks.length / projectTasks.length * 100) : 0;
          const weekAgo = /* @__PURE__ */ new Date();
          weekAgo.setDate(weekAgo.getDate() - 7);
          const recentTasks = projectTasks.filter(
            (task) => new Date(task.updatedAt || task.createdAt) > weekAgo
          );
          console.log(`\u{1F916} Generating AI talking points for project: ${project.name}`);
          const completion = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `You are an expert AI project management consultant creating focused meeting preparation for a specific project. Generate detailed talking points that serve as comprehensive speaking notes for the project owner.

Generate well-structured talking points in this format:

# \u{1F3AF} ${project.name} - Meeting Preparation

## \u{1F4CA} Project Status Overview
[Executive summary in 2-3 bullets with key metrics and current state]

## \u2705 Recent Accomplishments
[What's been completed recently with impact and significance]

## \u{1F525} Priority Items for Discussion
[Most important topics that need attention or decisions]

## \u26A0\uFE0F Risks & Blockers
[Current issues, potential problems, and items needing escalation]

## \u{1F4CB} Action Items & Next Steps
[Specific deliverables and upcoming milestones]

## \u{1F4A1} Discussion Topics
[Strategic questions and decisions needed]

Make the content:
- Specific and actionable
- Include concrete numbers and dates
- Highlight critical decisions needed
- Focus on outcomes and business impact
- Use bullet points for easy reference during the meeting`
              },
              {
                role: "user",
                content: `Create meeting preparation talking points for this project:

**PROJECT DETAILS:**
- Name: ${project.name}
- Description: ${project.description || "No description provided"}
- Status: ${project.status}
- Due Date: ${project.dueDate ? new Date(project.dueDate).toLocaleDateString() : "Not set"}
- Progress: ${progressPercentage}% complete

**TASK SUMMARY:**
- Total Tasks: ${projectTasks.length}
- Completed: ${completedTasks.length}
- In Progress: ${inProgressTasks.length}
- To Do: ${todoTasks.length}
- High Priority: ${highPriorityTasks.length}
- Overdue: ${overdueTasks.length}
- Recent Activity: ${recentTasks.length} tasks updated in last 7 days

**HIGH PRIORITY TASKS:**
${highPriorityTasks.slice(0, 5).map(
                  (task) => `- ${task.title} (${task.status}) - Priority: ${task.priority}${task.dueDate ? ` | Due: ${new Date(task.dueDate).toLocaleDateString()}` : ""}`
                ).join("\n") || "No high priority tasks"}

**OVERDUE TASKS:**
${overdueTasks.slice(0, 3).map(
                  (task) => `- ${task.title} - Due: ${new Date(task.dueDate).toLocaleDateString()}`
                ).join("\n") || "No overdue tasks"}

**RECENT COMPLETIONS:**
${completedTasks.filter(
                  (task) => new Date(task.updatedAt || task.createdAt) > weekAgo
                ).slice(0, 3).map(
                  (task) => `- ${task.title} - Completed recently`
                ).join("\n") || "No recent completions"}

Generate comprehensive talking points that help the project owner lead an effective meeting discussion.`
              }
            ]
          });
          const preparation = completion.choices[0].message.content || "Unable to generate meeting preparation at this time.";
          console.log(`\u2705 Generated project meeting preparation (${preparation.length} chars)`);
          return preparation;
        } catch (error) {
          console.error("Project meeting preparation error:", error);
          return `# Project Meeting Preparation

Unable to generate AI talking points at this time. Please try again later.

## Manual Preparation
- Review project status and recent progress
- Identify key decisions needed
- Prepare updates on critical tasks
- Note any blockers or risks to discuss`;
        }
      }
    };
    aiService = new AIService();
  }
});

// server/services/email.ts
import { Resend } from "resend";
var ResendEmailService, MockEmailService, emailService;
var init_email = __esm({
  "server/services/email.ts"() {
    "use strict";
    ResendEmailService = class {
      resend;
      constructor() {
        this.resend = new Resend(process.env.RESEND_API_KEY);
      }
      formatBriefingText(text2) {
        return text2.replace(/### (.*)/g, '<h3 style="color: #1e40af; margin: 20px 0 10px 0; font-size: 18px; font-weight: 600;">$1</h3>').replace(/\*\*(.*?)\*\*/g, '<strong style="color: #374151;">$1</strong>').split("\n\n").map((paragraph) => paragraph.trim()).filter((paragraph) => paragraph.length > 0).map((paragraph) => {
          if (paragraph.startsWith("<h3")) {
            return paragraph;
          }
          return `<p style="margin: 12px 0; color: #4b5563; line-height: 1.6;">${paragraph.replace(/\n/g, "<br>")}</p>`;
        }).join("");
      }
      async sendTestEmail(email) {
        if (!process.env.RESEND_API_KEY) {
          console.log(`Mock: Test email sent to ${email} (Resend API key not configured)`);
          return;
        }
        try {
          const { data, error } = await this.resend.emails.send({
            from: process.env.FROM_EMAIL || "AI ProjectHub <noreply@omarb.in>",
            to: [email],
            subject: "AI Project Manager - Test Email",
            html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #0079F2;">\u{1F916} Your AI Project Manager is Working!</h2>
            <p>This is a test email to confirm your email notifications are set up correctly.</p>
            <div style="background: #f0f9ff; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #0079F2;">
              <p style="margin: 0; color: #1e40af; font-weight: 500;">You'll receive smart notifications about:</p>
              <ul style="color: #374151; margin: 10px 0;">
                <li>Daily project summaries with AI insights</li>
                <li>Deadline alerts and overdue tasks</li>
                <li>Project health warnings</li>
                <li>Intelligent recommendations</li>
              </ul>
            </div>
            <p>Best regards,<br><strong>Your AI Project Manager</strong></p>
            <p style="color: #6b7280; font-size: 12px; margin-top: 30px;">
              Powered by advanced AI analysis of your project data
            </p>
          </div>
        `
          });
          if (error) {
            console.error("\u274C Resend email error:", error);
            console.error("\u274C Error details:", JSON.stringify(error, null, 2));
            if (error.message?.includes("verify a domain") || error.message?.includes("testing emails")) {
              console.log("\u{1F4E7} EMAIL DOMAIN ISSUE: Domain verification required");
              console.log("   \u2022 Check that omarb.in domain is verified at resend.com/domains");
              console.log("   \u2022 Ensure FROM_EMAIL uses the verified domain");
              console.log("   \u2022 Without domain verification, emails only work to the verified account");
            }
            if (error.message?.includes("API key")) {
              console.log("\u{1F511} API KEY ISSUE: Check RESEND_API_KEY configuration");
            }
            throw new Error(`Email delivery failed: ${error.message || "Unknown error"}`);
          }
          console.log(`Test email sent successfully to ${email}:`, data?.id);
        } catch (error) {
          console.error("Email send error:", error);
          throw error;
        }
      }
      async sendNotificationEmail(email, subject, content) {
        if (!process.env.RESEND_API_KEY) {
          console.log(`Mock: Email sent to ${email} - ${subject}: ${content}`);
          return;
        }
        try {
          const { data, error } = await this.resend.emails.send({
            from: process.env.FROM_EMAIL || "AI ProjectHub <noreply@omarb.in>",
            to: [email],
            subject: `AI Project Manager - ${subject}`,
            html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #333;">${subject}</h2>
            <div style="background: #f9f9f9; padding: 20px; border-radius: 8px; margin: 20px 0;">
              ${content}
            </div>
            <p style="color: #666; font-size: 12px;">
              This email was sent by your AI Project Manager. You can manage notification preferences in your settings.
            </p>
          </div>
        `
          });
          if (error) {
            throw error;
          }
          console.log(`Notification email sent to ${email}: ${subject}`, data?.id);
        } catch (error) {
          console.error("Notification email error:", error);
          throw error;
        }
      }
      async sendDailySummary(email, summary) {
        if (!process.env.RESEND_API_KEY) {
          console.log(`Mock: Daily summary sent to ${email}`, summary);
          return;
        }
        console.log(`\u{1F4E7} Preparing daily summary email for ${email}`);
        try {
          const { data, error } = await this.resend.emails.send({
            from: process.env.FROM_EMAIL || "AI ProjectHub <noreply@omarb.in>",
            to: [email],
            subject: `\u{1F305} Morning Summary - ${summary.date}`,
            html: `
      <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f8fafc;">
        <div style="background: white; border-radius: 12px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);">
          <div style="text-align: center; margin-bottom: 30px;">
            <h1 style="color: #1e293b !important; margin: 0 0 10px 0; font-size: 28px;">Morning Summary</h1>
            <p style="color: #64748b !important; margin: 0; font-size: 16px;">${summary.date}</p>
          </div>

          <div style="background-color: #3b82f6; padding: 25px; border-radius: 8px; margin-bottom: 25px;">
            <div style="text-align: center; margin-bottom: 15px;">
              <h2 style="color: #ffffff !important; margin: 0; font-size: 20px; font-weight: 700;">\u{1F305} Good Morning!</h2>
            </div>
            <div style="color: #ffffff !important; font-size: 15px; line-height: 1.5; text-align: left;">
              ${summary.smartBriefing ? summary.smartBriefing.split("\n").map(
              (line) => line.trim() ? `<p style="margin: 6px 0; color: #ffffff !important;">${line.trim()}</p>` : "<br>"
            ).join("") : '<p style="margin: 0; color: #ffffff !important; text-align: center;">Start your day with focus and purpose!</p>'}
            </div>
          </div>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
            <div style="background: #f1f5f9; padding: 20px; border-radius: 8px; text-align: center;">
              <div style="font-size: 32px; font-weight: bold; color: #059669 !important; margin-bottom: 5px;">${summary.completedToday || 0}</div>
              <div style="color: #374151 !important; font-size: 14px; font-weight: 600;">Tasks Completed</div>
            </div>
            <div style="background: #f1f5f9; padding: 20px; border-radius: 8px; text-align: center;">
              <div style="font-size: 32px; font-weight: bold; color: #3b82f6 !important; margin-bottom: 5px;">${summary.activeProjects || 0}</div>
              <div style="color: #374151 !important; font-size: 14px; font-weight: 600;">Active Projects</div>
            </div>
          </div>

          ${summary.keyRecommendations && summary.keyRecommendations.length > 0 ? `
          <div style="margin-bottom: 25px;">
            <h3 style="color: #1e293b !important; margin-bottom: 15px; font-size: 20px; font-weight: 700;">\u{1F389} Today's Priorities</h3>
            <div style="background: #ecfdf5; border-left: 4px solid #10b981; padding: 15px; border-radius: 0 8px 8px 0;">
              ${summary.keyRecommendations.map(
              (task) => `<div style="margin: 8px 0; color: #065f46 !important; font-weight: 600; line-height: 1.4;">${task}</div>`
            ).join("")}
            </div>
          </div>
          ` : ""}

          <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
            <p style="color: #374151 !important; font-size: 14px; margin: 0; font-weight: 500;">
              Have a productive day! Focus on what matters most.
            </p>
          </div>
        </div>
      </div>
    `,
            text: `Morning Summary - ${summary.date}

${summary.smartBriefing || "Start your day with focus and purpose"}

Today's Stats:
\u2022 Completed Tasks: ${summary.completedToday || 0}
\u2022 Active Projects: ${summary.activeProjects || 0}

${summary.keyRecommendations && summary.keyRecommendations.length > 0 ? `
Today's Priorities:
${summary.keyRecommendations.map((task) => `\u2022 ${task}`).join("\n")}
` : ""}

Have a productive day!`
          });
          if (error) {
            console.error("\u274C Daily summary email error:", error);
            console.error("\u274C Error details for daily summary:", JSON.stringify(error, null, 2));
            if (error.message?.includes("verify a domain") || error.message?.includes("testing emails")) {
              console.log(`\u{1F4E7} PRODUCTION EMAIL ISSUE: Daily summary generated but not sent to ${email}`);
              console.log("   \u2022 Domain verification required at resend.com");
              console.log("   \u2022 Check FROM_EMAIL environment variable");
              console.log("   \u2022 Verify omarb.in domain is active and verified");
              return;
            }
            if (error.message?.includes("API key")) {
              console.log("\u{1F511} RESEND API KEY ISSUE: Check environment variable RESEND_API_KEY");
              return;
            }
            throw error;
          }
          console.log(`Daily summary sent to ${email}`, data?.id);
        } catch (error) {
          console.error("Daily summary email error:", error);
          if (error.message?.includes("verify a domain") || error.message?.includes("testing emails")) {
            console.error(`\u274C EMAIL VERIFICATION ISSUE: Daily summary failed for ${email}`);
            console.error(`\u274C Error: ${error.message}`);
            throw error;
          }
          throw error;
        }
      }
      async sendLunchBriefing(email, briefing) {
        if (!process.env.RESEND_API_KEY) {
          console.log(`Mock: Lunch briefing sent to ${email}`, briefing);
          return;
        }
        console.log(`\u{1F4E7} Preparing lunch briefing email for ${email}`);
        try {
          const { data, error } = await this.resend.emails.send({
            from: process.env.FROM_EMAIL || "AI ProjectHub <noreply@omarb.in>",
            to: [email],
            subject: `\u{1F957} Lunch Summary - ${briefing.date}`,
            html: `
      <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f8fafc;">
        <div style="background: white; border-radius: 12px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);">
          <div style="text-align: center; margin-bottom: 30px;">
            <h1 style="color: #1e293b !important; margin: 0 0 10px 0; font-size: 28px;">Lunch Summary</h1>
            <p style="color: #64748b !important; margin: 0; font-size: 16px;">${briefing.date}</p>
          </div>

          <div style="background-color: #1e3a8a; padding: 25px; border-radius: 8px; margin-bottom: 25px;">
            <div style="text-align: center; margin-bottom: 15px;">
              <h2 style="color: #ffffff !important; margin: 0; font-size: 20px; font-weight: 700;">\u{1F957} Lunch Break</h2>
            </div>
            <div style="color: #ffffff !important; font-size: 15px; line-height: 1.5; text-align: left;">
              ${briefing.briefingContent ? briefing.briefingContent.split("\n").map(
              (line) => line.trim() ? `<p style="margin: 6px 0; color: #ffffff !important;">${line.trim()}</p>` : "<br>"
            ).join("") : '<p style="margin: 0; color: #ffffff !important; text-align: center;">Time to recharge and refocus!</p>'}
            </div>
          </div>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
            <div style="background: #f1f5f9; padding: 20px; border-radius: 8px; text-align: center;">
              <div style="font-size: 32px; font-weight: bold; color: #059669 !important; margin-bottom: 5px;">${briefing.morningProgress || 0}</div>
              <div style="color: #374151 !important; font-size: 14px; font-weight: 600;">Tasks Completed</div>
            </div>
            <div style="background: #f1f5f9; padding: 20px; border-radius: 8px; text-align: center;">
              <div style="font-size: 32px; font-weight: bold; color: #3b82f6 !important; margin-bottom: 5px;">${briefing.activeProjects || 0}</div>
              <div style="color: #374151 !important; font-size: 14px; font-weight: 600;">Active Projects</div>
            </div>
          </div>

          ${briefing.upcomingTasks && briefing.upcomingTasks.length > 0 ? `
          <div style="margin-bottom: 25px;">
            <h3 style="color: #1e293b !important; margin-bottom: 15px; font-size: 20px; font-weight: 700;">\u{1F389} Afternoon Priorities</h3>
            <div style="background: #ecfdf5; border-left: 4px solid #10b981; padding: 15px; border-radius: 0 8px 8px 0;">
              ${briefing.upcomingTasks.slice(0, 3).map(
              (task) => `<div style="margin: 8px 0; color: #065f46 !important; font-weight: 600; line-height: 1.4;">${task.title}</div>`
            ).join("")}
            </div>
          </div>
          ` : ""}

          <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
            <p style="color: #64748b; font-size: 14px; margin: 0;">
              Have a great afternoon! Tomorrow is a new opportunity to achieve great things.
            </p>
          </div>
        </div>
      </div>
    `,
            text: `Lunch Summary - ${briefing.date}

${briefing.briefingContent || "Time to recharge and refocus"}

Today's Stats:
\u2022 Completed Tasks: ${briefing.morningProgress || 0}
\u2022 Active Projects: ${briefing.activeProjects || 0}

${briefing.upcomingTasks && briefing.upcomingTasks.length > 0 ? `
Afternoon Priorities:
${briefing.upcomingTasks.slice(0, 3).map((task) => `\u2022 ${task.title}`).join("\n")}
` : ""}

Have a great afternoon!`
          });
          if (error) {
            console.error("\u274C Lunch briefing email error:", error);
            throw error;
          }
          console.log(`Lunch briefing sent to ${email}`, data?.id);
        } catch (error) {
          console.error("Lunch briefing email error:", error);
          throw error;
        }
      }
      async sendProjectAlert(email, projectName, alertType, message) {
        if (!process.env.RESEND_API_KEY) {
          console.log(`Mock: Project alert sent to ${email} - ${projectName}: ${message}`);
          return;
        }
        const priorityColors = {
          urgent: "#ef4444",
          high: "#f59e0b",
          medium: "#10b981",
          low: "#6b7280"
        };
        try {
          const { data, error } = await this.resend.emails.send({
            from: process.env.FROM_EMAIL || "AI ProjectHub <noreply@omarb.in>",
            to: [email],
            subject: `\u{1F6A8} Project Alert: ${projectName}`,
            html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <div style="background: ${priorityColors[alertType] || "#ef4444"}; color: white; padding: 20px; border-radius: 8px 8px 0 0;">
              <h2 style="margin: 0;">\u26A0\uFE0F Project Alert</h2>
              <p style="margin: 10px 0 0 0; opacity: 0.9;">Your attention is needed</p>
            </div>
            <div style="background: white; padding: 20px; border: 1px solid #e5e7eb; border-top: none; border-radius: 0 0 8px 8px;">
              <h3 style="color: #333; margin-top: 0;">Project: ${projectName}</h3>
              <p style="color: #666; font-size: 16px;">${message}</p>
              <div style="margin-top: 20px; padding: 15px; background: #f9fafb; border-radius: 6px;">
                <p style="margin: 0; color: #374151; font-weight: 500;">Recommended Action:</p>
                <p style="margin: 5px 0 0 0; color: #6b7280;">Review the project status and address any overdue tasks or resource conflicts.</p>
              </div>
            </div>
            <p style="color: #9ca3af; font-size: 12px; text-align: center; margin-top: 20px;">
              This alert was generated by your AI Project Manager
            </p>
          </div>
        `
          });
          if (error) {
            throw error;
          }
          console.log(`Project alert sent to ${email} for ${projectName}`, data?.id);
        } catch (error) {
          console.error("Project alert email error:", error);
          throw error;
        }
      }
      async sendTaskDeadlineAlert(email, taskTitle, projectName, dueDate, isOverdue = false, daysOverdue = 0, projectId, taskId) {
        if (!process.env.RESEND_API_KEY) {
          const alertType = isOverdue ? "OVERDUE" : "Deadline";
          console.log(`Mock: ${alertType} alert sent to ${email} - ${taskTitle} in ${projectName}`);
          return;
        }
        const subjectPrefix = isOverdue ? "\u{1F6A8} OVERDUE TASK" : "\u23F0 Task Deadline Alert";
        const headerText = isOverdue ? "\u{1F6A8} Task Overdue" : "\u23F0 Deadline Alert";
        const statusText = isOverdue ? `Task overdue by ${daysOverdue} day${daysOverdue !== 1 ? "s" : ""}` : "Task deadline approaching";
        const backgroundColor = isOverdue ? "linear-gradient(135deg, #ef4444, #dc2626)" : "linear-gradient(135deg, #f59e0b, #d97706)";
        const alertColor = isOverdue ? "#dc2626" : "#f59e0b";
        const alertBackgroundColor = isOverdue ? "#fee2e2" : "#fef3c7";
        const alertTextColor = isOverdue ? "#7f1d1d" : "#92400e";
        const urgencyMessage = isOverdue ? `This task is ${daysOverdue} day${daysOverdue !== 1 ? "s" : ""} overdue and requires immediate attention. Daily reminders will continue until completed.` : "This task needs your attention to meet its deadline. Daily reminders will continue until addressed.";
        const baseUrl = process.env.BASE_URL || "https://ai-projecthub.replit.app";
        const projectUrl = projectId ? `${baseUrl}/projects/${projectId}` : null;
        const taskUrl = projectId && taskId ? `${baseUrl}/projects/${projectId}?task=${taskId}` : null;
        try {
          const { data, error } = await this.resend.emails.send({
            from: process.env.FROM_EMAIL || "AI ProjectHub <noreply@omarb.in>",
            to: [email],
            subject: `${subjectPrefix}: ${taskTitle}`,
            html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <div style="background: ${backgroundColor}; color: white; padding: 20px; border-radius: 8px 8px 0 0;">
              <h2 style="margin: 0;">${headerText}</h2>
              <p style="margin: 10px 0 0 0; opacity: 0.9;">${statusText}</p>
            </div>
            <div style="background: white; padding: 20px; border: 1px solid #e5e7eb; border-top: none; border-radius: 0 0 8px 8px;">
              <h3 style="color: #333; margin-top: 0;">${taskTitle}</h3>
              <p style="color: #666;"><strong>Project:</strong> ${projectName}</p>
              <p style="color: #666;"><strong>Due Date:</strong> ${new Date(dueDate).toLocaleDateString()}</p>
              ${isOverdue ? `<p style="color: ${alertColor}; font-weight: bold;"><strong>Days Overdue:</strong> ${daysOverdue}</p>` : ""}
              
              <div style="background: ${alertBackgroundColor}; padding: 15px; border-radius: 6px; margin: 20px 0; border-left: 4px solid ${alertColor};">
                <p style="margin: 0; color: ${alertTextColor}; font-weight: 500;">
                  ${urgencyMessage}
                </p>
              </div>

              ${taskUrl || projectUrl ? `
              <div style="text-align: center; margin: 25px 0;">
                <h4 style="color: #374151; margin-bottom: 15px; font-size: 16px;">Quick Actions:</h4>
                <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
                  ${taskUrl ? `
                  <a href="${taskUrl}" 
                     style="display: inline-block; background: #3b82f6; color: white; padding: 12px 24px; 
                            text-decoration: none; border-radius: 6px; font-weight: 600; font-size: 14px;
                            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);">
                    \u{1F4DD} View Task
                  </a>
                  ` : ""}
                  ${projectUrl ? `
                  <a href="${projectUrl}" 
                     style="display: inline-block; background: #059669; color: white; padding: 12px 24px; 
                            text-decoration: none; border-radius: 6px; font-weight: 600; font-size: 14px;
                            box-shadow: 0 2px 4px rgba(5, 150, 105, 0.2);">
                    \u{1F4C2} Open Project
                  </a>
                  ` : ""}
                </div>
              </div>
              ` : ""}
            </div>
            <p style="color: #9ca3af; font-size: 12px; text-align: center; margin-top: 20px;">
              Daily reminder system - stay on track with AI-powered deadline monitoring
            </p>
          </div>
        `
          });
          if (error) {
            throw error;
          }
          const alertType = isOverdue ? "OVERDUE" : "Deadline";
          console.log(`${alertType} alert sent to ${email} for task: ${taskTitle}`, data?.id);
        } catch (error) {
          console.error("Deadline alert email error:", error);
          throw error;
        }
      }
      async sendProjectInvitation(inviteeEmail, projectName, inviterName, token, role) {
        if (!process.env.RESEND_API_KEY) {
          console.log(`Mock: Invitation email sent to ${inviteeEmail} for project ${projectName}`);
          return;
        }
        const acceptUrl = `${process.env.BASE_URL || "http://localhost:5000"}/invite/accept/${token}`;
        const declineUrl = `${process.env.BASE_URL || "http://localhost:5000"}/invite/decline/${token}`;
        try {
          const { data, error } = await this.resend.emails.send({
            from: process.env.FROM_EMAIL || "AI ProjectHub <noreply@omarb.in>",
            to: [inviteeEmail],
            subject: `You're invited to join "${projectName}"`,
            html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="text-align: center; margin-bottom: 30px;">
              <h1 style="color: #0079F2; margin: 0;">\u{1F91D} Project Invitation</h1>
            </div>
            
            <div style="background: #f9f9f9; padding: 25px; border-radius: 12px; margin: 20px 0; border-left: 4px solid #0079F2;">
              <h2 style="color: #333; margin: 0 0 15px 0;">You're invited to collaborate!</h2>
              <p style="color: #666; margin: 0; font-size: 16px; line-height: 1.5;">
                <strong>${inviterName}</strong> has invited you to join the project <strong>"${projectName}"</strong> as a <strong>${role}</strong>.
              </p>
            </div>

            <div style="background: #fff; padding: 25px; border-radius: 12px; border: 1px solid #e0e0e0; margin: 20px 0;">
              <h3 style="color: #333; margin: 0 0 15px 0;">What you'll get access to:</h3>
              <ul style="color: #666; margin: 0; padding-left: 20px; line-height: 1.6;">
                <li>\u{1F4CB} Project tasks and milestones</li>
                <li>\u{1F4C5} Team meetings and scheduling</li>
                <li>\u{1F916} AI-powered meeting transcriptions</li>
                <li>\u{1F4CA} Project progress and analytics</li>
                <li>\u{1F4AC} Team collaboration and discussions</li>
              </ul>
            </div>

            <div style="text-align: center; margin: 30px 0;">
              <a href="${acceptUrl}" 
                 style="display: inline-block; background: #0079F2; color: white; padding: 14px 28px; 
                        text-decoration: none; border-radius: 8px; font-weight: 600; margin: 0 10px; 
                        font-size: 16px; box-shadow: 0 2px 4px rgba(0, 121, 242, 0.2);">
                \u2705 Accept Invitation
              </a>
              <a href="${declineUrl}" 
                 style="display: inline-block; background: #6B7280; color: white; padding: 14px 28px; 
                        text-decoration: none; border-radius: 8px; font-weight: 600; margin: 0 10px; 
                        font-size: 16px; box-shadow: 0 2px 4px rgba(107, 114, 128, 0.2);">
                \u274C Decline
              </a>
            </div>

            <div style="background: #f0f9ff; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
              <p style="color: #1e40af; margin: 0; font-size: 14px;">
                \u{1F4A1} <strong>New to AI Project Manager?</strong><br>
                You'll be able to create an account or sign in when you accept the invitation.
              </p>
            </div>
            
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e0e0e0; text-align: center;">
              <p style="color: #999; font-size: 12px; margin: 0;">
                This invitation will expire in 7 days. If you have any questions, please contact ${inviterName}.
              </p>
              <p style="color: #999; font-size: 12px; margin: 10px 0 0 0;">
                Powered by AI Project Manager
              </p>
            </div>
          </div>
        `
          });
          if (error) {
            console.error("Invitation email error:", error);
            throw error;
          }
          console.log(`Invitation email sent to ${inviteeEmail} for project ${projectName}:`, data?.id);
        } catch (error) {
          console.error("Failed to send invitation email:", error);
          throw error;
        }
      }
      async sendEndOfDaySummary(email, summary) {
        const subject = `\u{1F305} End of Day Summary - ${summary.date}`;
        const htmlContent = `
      <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f8fafc;">
        <div style="background: white; border-radius: 12px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);">
          <div style="text-align: center; margin-bottom: 30px;">
            <h1 style="color: #1e293b; margin: 0 0 10px 0; font-size: 28px;">End of Day Summary</h1>
            <p style="color: #64748b; margin: 0; font-size: 16px;">${summary.date}</p>
          </div>

          <div style="background-color: #1e3a8a; padding: 25px; border-radius: 8px; margin-bottom: 25px;">
            <div style="text-align: center; margin-bottom: 15px;">
              <h2 style="color: #ffffff !important; margin: 0; font-size: 20px; font-weight: 700;">\u{1F307} End of Day</h2>
            </div>
            <div style="color: #ffffff !important; font-size: 15px; line-height: 1.5; text-align: center;">
              <p style="margin: 0; color: #ffffff !important;">${summary.message}</p>
            </div>
          </div>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
            <div style="background: #f1f5f9; padding: 20px; border-radius: 8px; text-align: center;">
              <div style="font-size: 32px; font-weight: bold; color: #059669; margin-bottom: 5px;">${summary.completedTasks}</div>
              <div style="color: #64748b; font-size: 14px;">Tasks Completed</div>
            </div>
            <div style="background: #f1f5f9; padding: 20px; border-radius: 8px; text-align: center;">
              <div style="font-size: 32px; font-weight: bold; color: #3b82f6; margin-bottom: 5px;">${summary.activeProjects}</div>
              <div style="color: #64748b; font-size: 14px;">Active Projects</div>
            </div>
          </div>

          ${summary.accomplishments.length > 0 ? `
          <div style="margin-bottom: 25px;">
            <h3 style="color: #1e293b; margin-bottom: 15px; font-size: 20px;">\u{1F389} Today's Accomplishments</h3>
            <div style="background: #ecfdf5; border-left: 4px solid #10b981; padding: 15px; border-radius: 0 8px 8px 0;">
              ${summary.accomplishments.map(
          (task) => `<div style="margin: 8px 0; color: #065f46;">\u2705 ${task}</div>`
        ).join("")}
            </div>
          </div>
          ` : ""}

          ${summary.tomorrowsPriorities.length > 0 ? `
          <div style="margin-bottom: 25px;">
            <h3 style="color: #1e293b; margin-bottom: 15px; font-size: 20px;">\u{1F680} Tomorrow's Priorities</h3>
            <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; border-radius: 0 8px 8px 0;">
              ${summary.tomorrowsPriorities.map(
          (task) => `<div style="margin: 8px 0; color: #92400e;">\u{1F4CB} ${task}</div>`
        ).join("")}
            </div>
          </div>
          ` : ""}

          <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
            <p style="color: #64748b; font-size: 14px; margin: 0;">
              Have a great evening! Tomorrow is a new opportunity to achieve great things.
            </p>
          </div>
        </div>
      </div>
    `;
        const textContent = `
End of Day Summary - ${summary.date}

${summary.message}

Today's Stats:
\u2022 Completed Tasks: ${summary.completedTasks}
\u2022 Active Projects: ${summary.activeProjects}

${summary.accomplishments.length > 0 ? `
Today's Accomplishments:
${summary.accomplishments.map((task) => `\u2022 ${task}`).join("\n")}
` : ""}

${summary.tomorrowsPriorities.length > 0 ? `
Tomorrow's Priorities:
${summary.tomorrowsPriorities.map((task) => `\u2022 ${task}`).join("\n")}
` : ""}

Have a great evening!
    `;
        try {
          await this.resend.emails.send({
            from: process.env.FROM_EMAIL || "AI ProjectHub <noreply@omarb.in>",
            to: [email],
            subject,
            html: htmlContent,
            text: textContent
          });
          console.log(`End of day summary sent successfully to ${email}`);
          return true;
        } catch (error) {
          console.error("End of day summary email error:", error);
          return false;
        }
      }
      async sendMeetingProcessedNotification(email, meetingTitle, projectName, tasksCreated, summaryPreview) {
        const subject = `\u{1F4CB} Meeting Processed: ${meetingTitle}`;
        const htmlContent = `
      <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f8fafc;">
        <div style="background: white; border-radius: 12px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);">
          <div style="text-align: center; margin-bottom: 30px;">
            <h1 style="color: #1e293b; margin: 0 0 10px 0; font-size: 28px;">\u{1F3A4} Meeting Processed</h1>
            <p style="color: #64748b; margin: 0; font-size: 16px;">${meetingTitle}</p>
          </div>

          <div style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 20px; border-radius: 8px; margin-bottom: 25px;">
            <p style="margin: 0; font-size: 18px; text-align: center;">
              \u2705 AI successfully processed your meeting recording
            </p>
          </div>

          <div style="background: #f1f5f9; padding: 20px; border-radius: 8px; margin-bottom: 25px;">
            <h3 style="color: #1e293b; margin-top: 0;">\u{1F4CA} Processing Results</h3>
            <ul style="list-style: none; padding: 0; margin: 0;">
              <li style="padding: 8px 0; border-bottom: 1px solid #e2e8f0;">
                <strong>Project:</strong> ${projectName}
              </li>
              <li style="padding: 8px 0; border-bottom: 1px solid #e2e8f0;">
                <strong>Tasks Created:</strong> ${tasksCreated} action items
              </li>
              <li style="padding: 8px 0;">
                <strong>Status:</strong> <span style="color: #10b981;">Complete & Ready</span>
              </li>
            </ul>
          </div>

          <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; border-radius: 0 8px 8px 0; margin-bottom: 25px;">
            <h4 style="margin-top: 0; color: #92400e;">\u{1F4DD} Summary Preview</h4>
            <p style="margin: 0; color: #92400e; font-style: italic;">${summaryPreview}</p>
          </div>

          <div style="text-align: center; margin-top: 30px;">
            <p style="color: #64748b; font-size: 14px; margin: 0;">
              \u{1F680} Your meeting tasks are now available in your project dashboard.
            </p>
          </div>
        </div>
      </div>
    `;
        const textContent = `
Meeting Processed: ${meetingTitle}

AI has successfully processed your meeting recording!

Results:
- Project: ${projectName}
- Tasks Created: ${tasksCreated} action items
- Status: Complete & Ready

Summary Preview: ${summaryPreview}

Your meeting tasks are now available in your project dashboard.
    `;
        try {
          await this.resend.emails.send({
            from: process.env.FROM_EMAIL || "AI ProjectHub <noreply@omarb.in>",
            to: [email],
            subject,
            html: htmlContent,
            text: textContent
          });
          console.log(`Meeting notification sent to ${email}: ${meetingTitle}`);
          return true;
        } catch (error) {
          console.error("Meeting notification email error:", error);
          return false;
        }
      }
    };
    MockEmailService = class {
      async sendTestEmail(email) {
        console.log(`Mock: Test email sent to ${email} (Resend API key not provided)`);
      }
      async sendNotificationEmail(email, subject, content) {
        console.log(`Mock: Email sent to ${email} - ${subject}: ${content}`);
      }
      async sendDailySummary(email, summary) {
        console.log(`Mock: Daily summary sent to ${email}:`, {
          date: summary.date,
          completedToday: summary.completedToday,
          productivityScore: summary.productivityScore,
          recommendations: summary.keyRecommendations?.length || 0
        });
      }
      async sendLunchBriefing(email, briefing) {
        console.log(`Mock: Lunch briefing sent to ${email}:`, {
          date: briefing.date,
          morningProgress: briefing.morningProgress,
          afternoonTasks: briefing.afternoonTasks,
          urgentAfternoon: briefing.urgentAfternoon,
          motivationalNote: briefing.motivationalNote
        });
      }
      async sendProjectAlert(email, projectName, alertType, message) {
        console.log(`Mock: Project alert sent to ${email} - ${projectName} (${alertType}): ${message}`);
      }
      async sendTaskDeadlineAlert(email, taskTitle, projectName, dueDate, isOverdue = false, daysOverdue = 0, projectId, taskId) {
        const alertType = isOverdue ? "OVERDUE" : "Deadline";
        console.log(`Mock: ${alertType} alert sent to ${email} - Task "${taskTitle}" in project "${projectName}" (Project ID: ${projectId}, Task ID: ${taskId})`);
      }
      async sendEndOfDaySummary(email, summary) {
        console.log(`Mock: End of day summary sent to ${email}:`, {
          date: summary.date,
          completedToday: summary.completedToday,
          productivityScore: summary.productivityScore,
          message: summary.message
        });
        return true;
      }
      async sendProjectInvitation(inviteeEmail, projectName, inviterName, token, role) {
        console.log(`Mock: Invitation email sent to ${inviteeEmail} for project ${projectName} by ${inviterName} as ${role} (token: ${token})`);
      }
    };
    emailService = process.env.RESEND_API_KEY ? new ResendEmailService() : new MockEmailService();
  }
});

// server/services/calendar-sync.ts
var calendar_sync_exports = {};
__export(calendar_sync_exports, {
  CalendarSyncService: () => CalendarSyncService
});
import { parseString } from "xml2js";
import { promisify } from "util";
var parseXML, CalendarSyncService;
var init_calendar_sync = __esm({
  "server/services/calendar-sync.ts"() {
    "use strict";
    parseXML = promisify(parseString);
    CalendarSyncService = class _CalendarSyncService {
      /**
       * Fetch and parse events from an Outlook shared calendar URL
       * Supports both ICS and XML formats
       */
      static async fetchOutlookEvents(sharedUrl) {
        try {
          console.log("Fetching calendar from URL:", sharedUrl);
          const response = await fetch(sharedUrl, {
            headers: {
              "User-Agent": "AI-ProjectHub/1.0 (Calendar Sync)"
            }
          });
          if (!response.ok) {
            throw new Error(`Failed to fetch calendar: ${response.status} ${response.statusText}`);
          }
          const contentType = response.headers.get("content-type") || "";
          const content = await response.text();
          if (contentType.includes("text/calendar") || sharedUrl.includes(".ics") || content.includes("BEGIN:VCALENDAR")) {
            return this.parseICSFormat(content);
          } else if (contentType.includes("xml") || content.includes("<?xml")) {
            return this.parseXMLFormat(content);
          } else if (content.includes("<!DOCTYPE html") || content.includes("<html")) {
            throw new Error("Received HTML page instead of calendar data. Please check your calendar sharing URL and permissions.");
          } else {
            try {
              return this.parseICSFormat(content);
            } catch (icsError) {
              throw new Error(`Unsupported calendar format. Expected ICS or XML but got: ${contentType}`);
            }
          }
        } catch (error) {
          console.error("Calendar sync error:", error);
          throw new Error(`Failed to sync calendar: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Parse ICS (iCalendar) format
       */
      static parseICSFormat(icsContent) {
        const events = [];
        const lines = icsContent.split("\n").map((line) => line.trim());
        let currentEvent = null;
        let isInEvent = false;
        for (const line of lines) {
          if (line === "BEGIN:VEVENT") {
            isInEvent = true;
            currentEvent = { source: "outlook" };
            continue;
          }
          if (line === "END:VEVENT" && currentEvent && isInEvent) {
            if (currentEvent.title && currentEvent.start) {
              if (!currentEvent.end) {
                currentEvent.end = new Date(currentEvent.start.getTime() + 60 * 60 * 1e3);
              }
              events.push({
                id: currentEvent.id || `outlook-${Date.now()}-${Math.random()}`,
                title: currentEvent.title,
                description: currentEvent.description,
                start: currentEvent.start,
                end: currentEvent.end,
                location: currentEvent.location,
                attendees: currentEvent.attendees || [],
                organizer: currentEvent.organizer,
                source: "outlook"
              });
            } else {
              console.log("FILTERED EVENT in calendar-sync:", {
                title: currentEvent.title || "MISSING TITLE",
                start: currentEvent.start || "MISSING START",
                hasTitle: !!currentEvent.title,
                hasStart: !!currentEvent.start,
                id: currentEvent.id,
                location: currentEvent.location
              });
            }
            currentEvent = null;
            isInEvent = false;
            continue;
          }
          if (isInEvent && currentEvent) {
            if (line.startsWith("UID:")) {
              currentEvent.id = line.substring(4);
            } else if (line.startsWith("SUMMARY:")) {
              currentEvent.title = _CalendarSyncService.unescapeICSText(line.substring(8));
            } else if (line.startsWith("DESCRIPTION:")) {
              currentEvent.description = _CalendarSyncService.unescapeICSText(line.substring(12));
            } else if (line.startsWith("LOCATION:")) {
              currentEvent.location = _CalendarSyncService.unescapeICSText(line.substring(9));
            } else if (line.startsWith("DTSTART:") || line.startsWith("DTSTART;")) {
              const dateStr = line.split(":")[1];
              const tzMatch = line.match(/TZID=([^:;]+)/);
              const timezone = tzMatch ? tzMatch[1] : null;
              currentEvent.start = _CalendarSyncService.parseICSDateWithTimezone(dateStr, timezone);
              console.log("RAW DTSTART:", {
                line,
                dateStr,
                timezone,
                parsed: currentEvent.start,
                iso: currentEvent.start.toISOString(),
                local: currentEvent.start.toLocaleString()
              });
            } else if (line.startsWith("STATUS:")) {
              const status = line.substring(7);
              console.log("EVENT STATUS:", status, "for", currentEvent.title || "untitled event");
            } else if (line.startsWith("CLASS:")) {
              const classification = line.substring(6);
              console.log("EVENT CLASS:", classification, "for", currentEvent.title || "untitled event");
            } else if (line.startsWith("ATTENDEE:")) {
              const attendeeMatch = line.match(/mailto:([^;]+)/);
              if (attendeeMatch) {
                if (!currentEvent.attendees) currentEvent.attendees = [];
                currentEvent.attendees.push(attendeeMatch[1]);
                console.log("ATTENDEE PARSED:", attendeeMatch[1], "for", currentEvent.title || "untitled event");
              }
            } else if (line.startsWith("ORGANIZER:")) {
              const organizerMatch = line.match(/mailto:([^;]+)/);
              if (organizerMatch) {
                currentEvent.organizer = organizerMatch[1];
                console.log("ORGANIZER PARSED:", organizerMatch[1], "for", currentEvent.title || "untitled event");
              }
            } else if (line.startsWith("DTEND:") || line.startsWith("DTEND;")) {
              const dateStr = line.split(":")[1];
              const tzMatch = line.match(/TZID=([^:;]+)/);
              const timezone = tzMatch ? tzMatch[1] : null;
              currentEvent.end = _CalendarSyncService.parseICSDateWithTimezone(dateStr, timezone);
            } else if (line.startsWith("RRULE:")) {
              const rrule = line.substring(6);
              console.log(`\u{1F504} FOUND RECURRING EVENT: ${currentEvent.title || "unnamed"} -> RRULE: ${rrule.substring(0, 50)}...`);
              currentEvent.recurring = rrule;
              currentEvent.isRecurring = true;
            } else if (line.includes("RRULE")) {
              console.log(`\u{1F50D} DEBUG: Found RRULE line but didn't process:`, line);
            }
          }
        }
        console.log(`Successfully parsed ${events.length} events from ICS`);
        const eventsByMonth = events.reduce((acc, event) => {
          const month = event.start.toISOString().substring(0, 7);
          acc[month] = (acc[month] || 0) + 1;
          return acc;
        }, {});
        console.log("Events by month:", eventsByMonth);
        console.log("Sample event titles:", events.slice(0, 5).map((e) => e.title));
        const todayEvents = events.filter((e) => {
          const eventDate = e.start.toISOString().split("T")[0];
          const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
          return eventDate === today;
        });
        if (todayEvents.length > 0) {
          console.log("TODAY'S EVENTS FOUND:", todayEvents.map((e) => ({
            title: e.title,
            time: e.start.toLocaleTimeString("en-US", { timeZone: "America/New_York" }),
            location: e.location
          })));
        } else {
          console.log("No events found for today - this might indicate missing calendar invites");
        }
        const inviteEvents = events.filter((e) => e.attendees && e.attendees.length > 0);
        console.log(`Found ${inviteEvents.length} events with attendees (likely calendar invites)`);
        const cancelledEvents = events.filter((e) => e.title?.includes("[CANCELLED]"));
        console.log(`Included ${cancelledEvents.length} cancelled events in results`);
        const recurringEvents = events.filter((e) => e.recurring || e.isRecurring);
        console.log(`Found ${recurringEvents.length} recurring events (these show only first occurrence)`);
        console.log("\u{1F4CB} Automatic recurring expansion disabled - showing only actual Outlook events");
        console.log(`
=== CALENDAR SYNC SUMMARY ===`);
        console.log(`Total events parsed: ${events.length}`);
        console.log(`Events with attendees: ${inviteEvents.length}`);
        console.log(`Recurring events found: ${recurringEvents.length}`);
        console.log(`Events today: ${todayEvents.length}`);
        console.log(`Date range: ${Math.min(...Object.keys(eventsByMonth).map((m) => m.replace("-", "")))} to ${Math.max(...Object.keys(eventsByMonth).map((m) => m.replace("-", "")))}`);
        if (recurringEvents.length > 0) {
          console.log(`
\u26A0\uFE0F  IMPORTANT: ${recurringEvents.length} recurring events are only showing their first occurrence.`);
          console.log(`   Missing meetings are likely instances of recurring events.`);
          console.log(`   To see all meetings, Outlook would need to provide expanded recurring events.`);
        }
        console.log(`============================
`);
        return events;
      }
      /**
       * DAY-OF-WEEK PATTERN RECURRING EVENT EXPANSION
       * Detects recurring meetings by day-of-week and time consistency
       */
      static expandRecurringEvents(events) {
        const expandedEvents = [...events];
        const recurringKeywords = ["weekly", "daily", "meeting", "standup", "review", "sync", "call", "check", "ops", "fd", "hk", "cro"];
        console.log(`\u{1F50D} DAY-OF-WEEK PATTERN ANALYSIS from ${events.length} total events...`);
        const eventsByTitle = events.reduce((acc, event) => {
          const title = event.title.trim();
          const titleLower = title.toLowerCase();
          const hasRecurringKeywords = recurringKeywords.some(
            (keyword) => titleLower.includes(keyword)
          );
          if (hasRecurringKeywords) {
            if (!acc[title]) acc[title] = [];
            acc[title].push(event);
          }
          return acc;
        }, {});
        console.log(`\u{1F50D} Found ${Object.keys(eventsByTitle).length} potential recurring meetings:`);
        const today = /* @__PURE__ */ new Date();
        const twoMonthsAhead = new Date(today);
        twoMonthsAhead.setMonth(twoMonthsAhead.getMonth() + 2);
        Object.entries(eventsByTitle).forEach(([title, eventGroup]) => {
          if (eventGroup.length >= 2) {
            console.log(`
\u{1F50D} Analyzing "${title}" (${eventGroup.length} instances):`);
            const patterns = eventGroup.map((event) => ({
              dayOfWeek: event.start.getDay(),
              // 0=Sunday, 1=Monday, etc.
              hour: event.start.getHours(),
              minute: event.start.getMinutes(),
              date: event.start.toISOString().split("T")[0],
              event
            }));
            console.log("   Instances:", patterns.map((p) => `${["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][p.dayOfWeek]} ${p.hour}:${p.minute.toString().padStart(2, "0")} (${p.date})`).join(", "));
            const dayOfWeekCounts = patterns.reduce((acc, p) => {
              acc[p.dayOfWeek] = (acc[p.dayOfWeek] || 0) + 1;
              return acc;
            }, {});
            const mostCommonDay = parseInt(Object.entries(dayOfWeekCounts).sort(([, a], [, b]) => b - a)[0]?.[0] || "-1");
            const dayEvents = patterns.filter((p) => p.dayOfWeek === mostCommonDay);
            if (dayEvents.length >= 2 && mostCommonDay >= 0) {
              const timeKey = (hour, minute) => `${hour}:${minute}`;
              const timeCounts = dayEvents.reduce((acc, p) => {
                const key = timeKey(p.hour, p.minute);
                acc[key] = (acc[key] || 0) + 1;
                return acc;
              }, {});
              const mostCommonTime = Object.entries(timeCounts).sort(([, a], [, b]) => b - a)[0]?.[0];
              if (mostCommonTime) {
                const [hour, minute] = mostCommonTime.split(":").map(Number);
                const dayName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][mostCommonDay];
                console.log(`   \u{1F3AF} PATTERN DETECTED: Every ${dayName} at ${hour}:${minute.toString().padStart(2, "0")}`);
                const lastKnownEvent = eventGroup.sort((a, b) => b.start.getTime() - a.start.getTime())[0];
                let checkDate = new Date(today);
                let instancesGenerated = 0;
                for (let week = 0; week < 8 && instancesGenerated < 6; week++) {
                  const targetDate = new Date(checkDate);
                  const daysUntilTarget = (mostCommonDay - targetDate.getDay() + 7) % 7;
                  targetDate.setDate(targetDate.getDate() + daysUntilTarget);
                  targetDate.setHours(hour, minute, 0, 0);
                  if (targetDate > today && targetDate <= twoMonthsAhead) {
                    const existsOnDate = eventGroup.some((e) => {
                      const timeDiff = Math.abs(e.start.getTime() - targetDate.getTime());
                      return timeDiff < 2 * 60 * 60 * 1e3;
                    });
                    if (!existsOnDate) {
                      const duration = lastKnownEvent.end.getTime() - lastKnownEvent.start.getTime();
                      const expandedEvent = {
                        id: `expanded-${lastKnownEvent.id}-${targetDate.toISOString().split("T")[0]}`,
                        title: lastKnownEvent.title,
                        description: lastKnownEvent.description,
                        start: new Date(targetDate),
                        end: new Date(targetDate.getTime() + duration),
                        location: lastKnownEvent.location,
                        source: "outlook"
                      };
                      expandedEvents.push(expandedEvent);
                      instancesGenerated++;
                      console.log(`   \u{1F504} Generated: ${dayName} ${targetDate.toLocaleDateString()}`);
                    }
                  }
                  checkDate.setDate(checkDate.getDate() + 7);
                }
              }
            }
          }
        });
        return expandedEvents;
      }
      /**
       * Parse XML format (Outlook Web Access RSS feeds)
       */
      static async parseXMLFormat(xmlContent) {
        try {
          const result = await parseXML(xmlContent);
          const events = [];
          if (result.rss && result.rss.channel && result.rss.channel[0].item) {
            const items = result.rss.channel[0].item;
            for (const item of items) {
              const title = item.title?.[0] || "Untitled Event";
              const description = item.description?.[0] || "";
              const pubDate = item.pubDate?.[0];
              const dateMatch = description.match(/(\d{1,2}\/\d{1,2}\/\d{4})/);
              const timeMatch = description.match(/(\d{1,2}:\d{2}(?:\s*[AP]M)?)/i);
              let startDate = pubDate ? new Date(pubDate) : /* @__PURE__ */ new Date();
              let endDate = new Date(startDate.getTime() + 60 * 60 * 1e3);
              if (dateMatch && timeMatch) {
                const [month, day, year] = dateMatch[1].split("/").map(Number);
                const timeStr = timeMatch[1];
                startDate = /* @__PURE__ */ new Date(`${month}/${day}/${year} ${timeStr}`);
                endDate = new Date(startDate.getTime() + 60 * 60 * 1e3);
              }
              events.push({
                id: `outlook-xml-${Date.now()}-${Math.random()}`,
                title,
                description,
                start: startDate,
                end: endDate,
                source: "outlook"
              });
            }
          }
          return events;
        } catch (error) {
          console.error("XML parsing error:", error);
          return [];
        }
      }
      /**
       * Parse ICS date format with proper timezone handling
       */
      static parseICSDateWithTimezone(dateStr, timezone) {
        try {
          if (dateStr.includes("T")) {
            const year = parseInt(dateStr.substring(0, 4));
            const month = parseInt(dateStr.substring(4, 6)) - 1;
            const day = parseInt(dateStr.substring(6, 8));
            const hour = parseInt(dateStr.substring(9, 11));
            const minute = parseInt(dateStr.substring(11, 13));
            const second = parseInt(dateStr.substring(13, 15)) || 0;
            console.log(`Parsing ICS date with timezone: ${dateStr} in ${timezone || "no timezone"}`);
            if (dateStr.endsWith("Z")) {
              const utcDate = new Date(Date.UTC(year, month, day, hour, minute, second));
              console.log(`UTC date: ${utcDate.toISOString()}`);
              return utcDate;
            } else if (timezone) {
              let utcOffset = 0;
              if (timezone.includes("Eastern")) {
                const isDST = month >= 2 && month <= 10;
                utcOffset = isDST ? 4 : 5;
                console.log(`${timezone} (${isDST ? "EDT" : "EST"}) time: ${year}/${month + 1}/${day} ${hour}:${minute} -> UTC offset: ${utcOffset} hours`);
              }
              const eventDate = new Date(Date.UTC(year, month, day, hour + utcOffset, minute, second));
              console.log(`Final UTC time: ${eventDate.toISOString()}`);
              return eventDate;
            } else {
              const localDate = new Date(year, month, day, hour, minute, second);
              console.log(`No timezone specified: ${localDate.toISOString()}`);
              return localDate;
            }
          } else {
            const year = parseInt(dateStr.substring(0, 4));
            const month = parseInt(dateStr.substring(4, 6)) - 1;
            const day = parseInt(dateStr.substring(6, 8));
            const allDayDate = new Date(Date.UTC(year, month, day, 12, 0, 0));
            console.log(`All-day event: ${dateStr} -> ${allDayDate.toISOString()}`);
            return allDayDate;
          }
        } catch (error) {
          console.error("Error parsing ICS date:", dateStr, error);
          return /* @__PURE__ */ new Date();
        }
      }
      /**
       * Parse ICS date format (legacy method for compatibility)
       */
      static parseICSDate(dateStr) {
        return this.parseICSDateWithTimezone(dateStr, null);
      }
      /**
       * Unescape ICS text content
       */
      static unescapeICSText(text2) {
        return text2.replace(/\\n/g, "\n").replace(/\\,/g, ",").replace(/\\;/g, ";").replace(/\\\\/g, "\\");
      }
      /**
       * Validate if a URL looks like a valid calendar share URL
       */
      static isValidCalendarUrl(url) {
        try {
          const parsedUrl = new URL(url);
          const outlookPatterns = [
            /outlook\.live\.com/,
            /outlook\.office365\.com/,
            /outlook\.office\.com/,
            /calendar/,
            /webcal:/
          ];
          const hasOutlookPattern = outlookPatterns.some((pattern) => pattern.test(url));
          const isIcsFormat = url.endsWith(".ics") || url.includes("webcal:");
          return hasOutlookPattern && (isIcsFormat || url.includes("calendar"));
        } catch {
          return false;
        }
      }
      /**
       * Auto-fix common URL format issues
       */
      static fixCalendarUrl(url) {
        if (url.includes("outlook") && url.endsWith(".html")) {
          return url.replace(".html", ".ics");
        }
        if (url.startsWith("webcal://")) {
          return url.replace("webcal://", "https://");
        }
        return url;
      }
    };
  }
});

// server/services/ics-parser.ts
var ics_parser_exports = {};
__export(ics_parser_exports, {
  IcsParserService: () => IcsParserService
});
var IcsParserService;
var init_ics_parser = __esm({
  "server/services/ics-parser.ts"() {
    "use strict";
    IcsParserService = class {
      static parseIcsContent(icsContent) {
        const events = [];
        const lines = icsContent.split(/\r?\n/);
        const rruleCount = lines.filter((line) => line.trim().startsWith("RRULE:")).length;
        console.log(`Found ${rruleCount} RRULE lines in ICS file`);
        let currentEvent = null;
        let multiLineValue = "";
        let multiLineProperty = "";
        for (let i = 0; i < lines.length; i++) {
          let line = lines[i].trim();
          if (line.startsWith(" ") || line.startsWith("	")) {
            multiLineValue += line.substring(1);
            continue;
          }
          if (multiLineProperty && multiLineValue) {
            this.processProperty(currentEvent, multiLineProperty, multiLineValue);
            multiLineProperty = "";
            multiLineValue = "";
          }
          if (line === "BEGIN:VEVENT") {
            currentEvent = {
              type: "calendar_event",
              id: `imported_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            };
          } else if (line === "END:VEVENT" && currentEvent) {
            if (currentEvent.start) {
              if (!currentEvent.title) {
                currentEvent.title = currentEvent.location || currentEvent.description?.substring(0, 30) + "..." || "Calendar Event";
              }
              if (currentEvent.cancelled) {
                currentEvent.title = `[CANCELLED] ${currentEvent.title}`;
              }
              if (currentEvent.recurring) {
                console.log("EVENT WITH RRULE COMPLETED:", currentEvent.title, "RRULE:", currentEvent.recurring.substring(0, 50) + "...");
              }
              events.push(currentEvent);
            } else {
              console.log("FILTERED EVENT (no start time):", {
                title: currentEvent.title || "MISSING",
                id: currentEvent.id,
                location: currentEvent.location,
                isRecurring: !!currentEvent.recurring,
                description: currentEvent.description?.substring(0, 50) + "..."
              });
            }
            currentEvent = null;
          } else if (currentEvent && line.includes(":")) {
            const colonIndex = line.indexOf(":");
            const property = line.substring(0, colonIndex);
            const value = line.substring(colonIndex + 1);
            if (value.length > 0) {
              this.processProperty(currentEvent, property, value);
            } else {
              multiLineProperty = property;
              multiLineValue = value;
            }
          }
        }
        return events;
      }
      static processProperty(event, property, value) {
        if (!event) return;
        const [propName, ...params] = property.split(";");
        switch (propName) {
          case "UID":
            event.id = value;
            break;
          case "SUMMARY":
            event.title = this.unescapeText(value);
            break;
          case "DESCRIPTION":
            event.description = this.unescapeText(value);
            break;
          case "LOCATION":
            event.location = this.unescapeText(value);
            break;
          case "DTSTART":
            event.start = this.parseDateTime(value, params);
            if (value.length === 8) {
              event.allDay = true;
            }
            break;
          case "DTEND":
            event.end = this.parseDateTime(value, params);
            break;
          case "STATUS":
            event.status = value;
            if (value === "CANCELLED") {
              event.cancelled = true;
            }
            console.log("EVENT STATUS:", value, "for event with ID:", event.id);
            break;
          case "CLASS":
            event.classification = value;
            console.log("Event classification:", value, "for event:", event.title || event.id || "UNNAMED");
            break;
          case "TRANSP":
            event.transparency = value;
            break;
          case "ATTENDEE":
            if (!event.attendees) event.attendees = [];
            event.attendees.push(value);
            console.log("FOUND ATTENDEE:", value, "for event:", event.title || event.id || "UNNAMED");
            break;
          case "ORGANIZER":
            event.organizer = this.unescapeText(value);
            break;
          case "RRULE":
            console.log("FOUND RECURRING EVENT:", event.title || event.id || "UNNAMED", "RRULE:", value.substring(0, 50) + "...");
            event.recurring = value;
            event.isRecurring = true;
            break;
          default:
            if (["CREATED", "LAST-MODIFIED", "DTSTAMP", "SEQUENCE", "X-MICROSOFT-CDO-APPT-SEQUENCE", "X-MICROSOFT-CDO-BUSYSTATUS", "X-MICROSOFT-CDO-INTENDEDSTATUS", "X-MICROSOFT-CDO-ALLDAYEVENT", "X-MICROSOFT-CDO-IMPORTANCE", "X-MICROSOFT-CDO-INSTTYPE", "X-MICROSOFT-DONOTFORWARDMEETING", "X-MICROSOFT-DISALLOW-COUNTER", "X-MICROSOFT-REQUESTEDATTENDANCEMODE", "X-MICROSOFT-ISRESPONSEREQUESTED"].includes(propName)) {
              break;
            }
            console.log("UNHANDLED ICS PROPERTY:", propName, "=", value.substring(0, 50) + (value.length > 50 ? "..." : ""));
            break;
        }
      }
      static parseDateTime(dateTimeStr, params) {
        console.log("RAW DTSTART:", {
          line: `DTSTART${params.length ? ";" + params.join(";") : ""}:${dateTimeStr}`,
          dateStr: dateTimeStr,
          hasTimezone: params.some((p) => p.startsWith("TZID=")),
          params
        });
        if (dateTimeStr.startsWith("1601") || dateTimeStr.length < 8) {
          console.log("SKIPPING INVALID DATE:", dateTimeStr);
          throw new Error(`Invalid date: ${dateTimeStr}`);
        }
        const tzidParam = params.find((p) => p.startsWith("TZID="));
        const timezone = tzidParam ? tzidParam.substring(5) : null;
        if (dateTimeStr.length === 8) {
          const year2 = dateTimeStr.substring(0, 4);
          const month2 = dateTimeStr.substring(4, 6);
          const day2 = dateTimeStr.substring(6, 8);
          const parsed2 = `${year2}-${month2}-${day2}T00:00:00.000Z`;
          return parsed2;
        }
        const year = dateTimeStr.substring(0, 4);
        const month = dateTimeStr.substring(4, 6);
        const day = dateTimeStr.substring(6, 8);
        const hour = dateTimeStr.substring(9, 11) || "00";
        const minute = dateTimeStr.substring(11, 13) || "00";
        const second = dateTimeStr.substring(13, 15) || "00";
        if (dateTimeStr.endsWith("Z")) {
          const parsed2 = `${year}-${month}-${day}T${hour}:${minute}:${second}.000Z`;
          return parsed2;
        }
        if (timezone) {
          const isoTime = `${year}-${month}-${day}T${hour}:${minute}:${second}.000Z`;
          return isoTime;
        }
        const parsed = `${year}-${month}-${day}T${hour}:${minute}:${second}.000Z`;
        return parsed;
      }
      static unescapeText(text2) {
        return text2.replace(/\\n/g, "\n").replace(/\\,/g, ",").replace(/\\;/g, ";").replace(/\\\\/g, "\\");
      }
      static validateIcsFile(content) {
        const lines = content.split(/\r?\n/);
        const hasBeginCalendar = lines.some((line) => line.trim() === "BEGIN:VCALENDAR");
        const hasEndCalendar = lines.some((line) => line.trim() === "END:VCALENDAR");
        const hasEvents = lines.some((line) => line.trim() === "BEGIN:VEVENT");
        return hasBeginCalendar && hasEndCalendar && hasEvents;
      }
      static getFileStats(content) {
        const events = this.parseIcsContent(content);
        if (events.length === 0) {
          return { eventCount: 0 };
        }
        const dates = events.map((e) => new Date(e.start)).filter((d) => !isNaN(d.getTime())).sort((a, b) => a.getTime() - b.getTime());
        if (dates.length === 0) {
          return { eventCount: events.length };
        }
        return {
          eventCount: events.length,
          dateRange: {
            start: dates[0].toISOString(),
            end: dates[dates.length - 1].toISOString()
          }
        };
      }
    };
  }
});

// server/scheduler.ts
var scheduler_exports = {};
__export(scheduler_exports, {
  scheduler: () => scheduler
});
var NotificationScheduler, scheduler;
var init_scheduler = __esm({
  "server/scheduler.ts"() {
    "use strict";
    init_storage();
    init_ai();
    init_email();
    NotificationScheduler = class {
      intervals = [];
      lastDailySummaryDate = "";
      lastLunchReminderDate = "";
      lastEndOfDayDate = "";
      lastResetDate = "";
      // Track when we last reset alerts
      sentDeadlineAlerts = /* @__PURE__ */ new Set();
      // Track sent alerts per day
      sentProjectHealthAlerts = /* @__PURE__ */ new Set();
      // Track project health alerts per day
      async getAllUsers() {
        try {
          const users2 = await storage.getAllUsers();
          return users2.map((user) => user.id);
        } catch (error) {
          console.error("Failed to get users for notifications:", error);
          return [];
        }
      }
      // Helper function to get all collaborators for a project (owner + members)
      async getProjectCollaborators(projectId) {
        try {
          const project = await storage.getProject(projectId);
          if (!project) return [];
          const collaboratorIds = [project.ownerId];
          const members = await storage.getProjectMembers(projectId);
          members.forEach((member) => {
            if (!collaboratorIds.includes(member.userId)) {
              collaboratorIds.push(member.userId);
            }
          });
          return collaboratorIds;
        } catch (error) {
          console.error("Failed to get project collaborators:", error);
          return [];
        }
      }
      start() {
        console.log("Starting AI notification scheduler...");
        const urgentCheck = setInterval(async () => {
          await this.checkUrgentNotifications();
        }, 5 * 60 * 1e3);
        const resetAlertsCheck = setInterval(() => {
          const now = /* @__PURE__ */ new Date();
          const utcHour = now.getUTCHours();
          const utcMinutes = now.getUTCMinutes();
          if (utcHour === 0 && utcMinutes >= 0 && utcMinutes < 5) {
            const today = `${now.getUTCFullYear()}-${String(now.getUTCMonth() + 1).padStart(2, "0")}-${String(now.getUTCDate()).padStart(2, "0")}`;
            if (this.lastResetDate !== today) {
              const previousSize = this.sentDeadlineAlerts.size;
              this.sentDeadlineAlerts.clear();
              this.sentProjectHealthAlerts.clear();
              this.lastResetDate = today;
              console.log(`\u{1F504} Reset alert trackers for new day ${today} - cleared ${previousSize} deadline alerts`);
            }
          }
        }, 5 * 60 * 1e3);
        const briefingCheck = setInterval(async () => {
          const now = /* @__PURE__ */ new Date();
          const easternTime = new Date(now.toLocaleString("en-US", { timeZone: "America/New_York" }));
          const today = easternTime.toISOString().split("T")[0];
          const hour = easternTime.getHours();
          const minutes = easternTime.getMinutes();
          if (hour === 7 && minutes >= 0 && minutes <= 5) {
            if (this.lastDailySummaryDate !== today) {
              console.log(`\u{1F305} Triggering morning briefings for ${today} at 7 AM`);
              this.lastDailySummaryDate = today;
              await this.sendMorningBriefings();
            }
          }
          if (hour === 12 && minutes >= 0 && minutes <= 5) {
            if (!this.lastLunchReminderDate || this.lastLunchReminderDate !== today) {
              console.log(`\u{1F957} Triggering lunch reminders for ${today} at 12 PM`);
              this.lastLunchReminderDate = today;
              await this.sendLunchReminders();
            }
          }
          if (hour === 17 && minutes >= 0 && minutes <= 5) {
            if (this.lastEndOfDayDate !== today) {
              console.log(`\u{1F307} Triggering end-of-day summaries for ${today} at 5 PM`);
              this.lastEndOfDayDate = today;
              await this.sendEndOfDaySummary();
            }
          }
        }, 60 * 1e3);
        const healthCheck = setInterval(async () => {
          await this.checkProjectHealth();
        }, 60 * 60 * 1e3);
        this.intervals.push(urgentCheck, resetAlertsCheck, briefingCheck, healthCheck);
      }
      stop() {
        this.intervals.forEach((interval) => clearInterval(interval));
        this.intervals = [];
        console.log("Stopped AI notification scheduler");
      }
      async checkUrgentNotifications() {
        try {
          const userIds = await this.getAllUsers();
          for (const userId of userIds) {
            const tasks2 = await storage.getTasks(void 0, userId);
            const now = /* @__PURE__ */ new Date();
            for (const task of tasks2) {
              if (task.dueDate && task.status !== "completed") {
                const dueDate = new Date(task.dueDate);
                const hoursUntilDue = (dueDate.getTime() - now.getTime()) / (1e3 * 60 * 60);
                if (hoursUntilDue <= 4 && hoursUntilDue >= -168) {
                  const utcDate = /* @__PURE__ */ new Date();
                  const today = `${utcDate.getUTCFullYear()}-${String(utcDate.getUTCMonth() + 1).padStart(2, "0")}-${String(utcDate.getUTCDate()).padStart(2, "0")}`;
                  const alertId = `${task.id}_${today}`;
                  if (this.sentDeadlineAlerts.has(alertId)) {
                    console.log(`\u23ED\uFE0F Deadline alert already sent today for task "${task.title}" (alert ID: ${alertId}, current alerts: ${this.sentDeadlineAlerts.size})`);
                    continue;
                  }
                  console.log(`\u{1F50D} Processing deadline alert for task "${task.title}" - hours until due: ${hoursUntilDue.toFixed(1)}, alert ID: ${alertId}`);
                  const project = await storage.getProject(task.projectId);
                  if (!project) continue;
                  const collaboratorIds = await this.getProjectCollaborators(task.projectId);
                  let alertSentToAnyUser = false;
                  for (const collaboratorId of collaboratorIds) {
                    const settings = await storage.getUserSettings(collaboratorId);
                    if (!settings?.emailNotifications || !settings?.taskDeadlineAlerts) {
                      continue;
                    }
                    if (settings.urgentOnly && hoursUntilDue > 0) {
                      continue;
                    }
                    const collaborator = await storage.getUser(collaboratorId);
                    if (collaborator?.email) {
                      const isOverdue = hoursUntilDue < 0;
                      const daysOverdue = Math.abs(Math.floor(hoursUntilDue / 24));
                      await emailService.sendTaskDeadlineAlert(
                        collaborator.email,
                        task.title,
                        project.name,
                        task.dueDate.toString(),
                        isOverdue,
                        daysOverdue,
                        task.projectId,
                        // Pass projectId for direct link
                        task.id
                        // Pass taskId for direct link
                      );
                      const alertType = isOverdue ? "OVERDUE" : "DEADLINE";
                      console.log(`\u23F0 ${alertType} alert sent for task "${task.title}" to ${collaborator.email} (daily reminder)`);
                      alertSentToAnyUser = true;
                    }
                  }
                  if (alertSentToAnyUser) {
                    this.sentDeadlineAlerts.add(alertId);
                    console.log(`\u2705 Marked deadline alert as sent for today: ${alertId} (total tracked alerts: ${this.sentDeadlineAlerts.size})`);
                  } else {
                    console.log(`\u26A0\uFE0F No alerts sent for task "${task.title}" - no eligible collaborators found`);
                  }
                }
              }
            }
          }
        } catch (error) {
          console.error("Urgent notifications check failed:", error);
        }
      }
      async sendMorningBriefings() {
        try {
          const userIds = await this.getAllUsers();
          console.log(`Daily summary check - found ${userIds.length} users`);
          for (const userId of userIds) {
            const user = await storage.getUser(userId);
            console.log(`Processing daily summary for user: ${user?.email || userId}`);
            let settings = await storage.getUserSettings(userId);
            if (!settings) {
              console.log(`Creating default settings for user: ${user?.email}`);
              settings = await storage.createUserSettings({
                userId,
                emailNotifications: true,
                morningBriefing: true,
                lunchReminder: true,
                taskDeadlineAlerts: true,
                endOfDaySummary: true,
                urgentOnly: false,
                workingHoursStart: "09:00",
                workingHoursEnd: "18:00"
              });
            }
            if (!settings?.emailNotifications || !settings?.morningBriefing) {
              console.log(`Daily summary skipped for ${user?.email} - user preferences disabled`);
              continue;
            }
            const projects2 = await storage.getProjects(userId);
            const tasks2 = await storage.getTasks(void 0, userId);
            const summary = await aiService.generateSmartDailyBriefing(projects2, tasks2, userId, user?.name);
            if (user?.email) {
              console.log(`Generating daily summary for: ${user.email}`);
              try {
                await emailService.sendDailySummary(user.email, summary);
                console.log(`\u2705 Daily summary sent successfully to: ${user.email}`);
              } catch (error) {
                console.error(`\u274C Daily summary failed for ${user.email}:`, error?.message || error);
                if (error?.message?.includes("verify a domain") || error?.message?.includes("testing emails")) {
                  console.error("\u{1F527} PRODUCTION FIX NEEDED: Email domain not verified - check Resend dashboard");
                }
              }
            } else {
              console.log(`Skipping daily summary - no email for user: ${userId}`);
            }
          }
          console.log("Morning briefings sent successfully");
        } catch (error) {
          console.error("Morning briefing failed:", error);
        }
      }
      // New lunch reminder functionality
      async sendLunchReminders() {
        try {
          const userIds = await this.getAllUsers();
          console.log(`Lunch reminder check - found ${userIds.length} users`);
          for (const userId of userIds) {
            const settings = await storage.getUserSettings(userId);
            if (!settings?.emailNotifications || !settings?.lunchReminder) {
              console.log(`Lunch briefing skipped for ${userId} - user preferences disabled`);
              continue;
            }
            const user = await storage.getUser(userId);
            if (user?.email) {
              const projects2 = await storage.getProjects(userId);
              const tasks2 = await storage.getTasks(void 0, userId);
              const lunchBriefing = await aiService.generateLunchBriefing(projects2, tasks2, userId);
              try {
                await emailService.sendLunchBriefing(user.email, lunchBriefing);
                console.log(`\u2705 Lunch briefing sent successfully to: ${user.email}`);
              } catch (error) {
                console.error(`\u274C Lunch briefing failed for ${user.email}:`, error?.message || error);
              }
            }
          }
          console.log("Lunch briefings sent successfully");
        } catch (error) {
          console.error("Lunch briefing failed:", error);
        }
      }
      async sendEndOfDaySummary() {
        try {
          const userIds = await this.getAllUsers();
          for (const userId of userIds) {
            const settings = await storage.getUserSettings(userId);
            if (!settings?.emailNotifications || !settings?.endOfDaySummary) {
              console.log("End of day summary skipped - user preferences disabled");
              continue;
            }
            const stats = await storage.getDashboardStats(userId);
            const tasks2 = await storage.getTasks(void 0, userId);
            const projects2 = await storage.getProjects(userId);
            const today = /* @__PURE__ */ new Date();
            const todayString = today.toDateString();
            const completedToday = tasks2.filter(
              (task) => task.status === "completed" && task.updatedAt && new Date(task.updatedAt).toDateString() === todayString
            );
            const tomorrowsPriorities = tasks2.filter(
              (task) => task.status !== "completed" && (task.priority === "high" || task.priority === "urgent")
            ).map((task) => task.title).slice(0, 3);
            const summary = {
              date: today.toLocaleDateString("en-US", {
                weekday: "long",
                year: "numeric",
                month: "long",
                day: "numeric"
              }),
              completedTasks: completedToday.length,
              // Fixed field name to match email template
              activeProjects: projects2.length,
              productivityScore: Math.round(completedToday.length / Math.max(tasks2.length, 1) * 100),
              accomplishments: completedToday.filter(
                (task) => task.priority === "high" || task.priority === "urgent"
              ).map((task) => task.title).slice(0, 3),
              tomorrowsPriorities,
              // Added missing field
              message: completedToday.length > 0 ? `Great work today! You completed ${completedToday.length} tasks across ${projects2.length} projects.` : `Ready for tomorrow! You have ${projects2.length} active projects to focus on.`
            };
            const user = await storage.getUser(userId);
            if (user?.email) {
              await emailService.sendEndOfDaySummary(user.email, summary);
            }
          }
          console.log("End of day summary sent successfully");
        } catch (error) {
          console.error("End of day summary failed:", error);
        }
      }
      async checkProjectHealth() {
        try {
          const userIds = await this.getAllUsers();
          const checkedProjects = /* @__PURE__ */ new Set();
          for (const userId of userIds) {
            const projects2 = await storage.getProjects(userId);
            for (const project of projects2) {
              if (checkedProjects.has(project.id)) {
                continue;
              }
              checkedProjects.add(project.id);
              const insights = { healthScore: 75, riskFactors: ["Minor delays detected"] };
              if (insights.healthScore < 60) {
                const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
                const healthAlertId = `${project.id}_health_${today}`;
                if (this.sentProjectHealthAlerts.has(healthAlertId)) {
                  continue;
                }
                const collaboratorIds = await this.getProjectCollaborators(project.id);
                let healthAlertSentToAnyUser = false;
                for (const collaboratorId of collaboratorIds) {
                  const settings = await storage.getUserSettings(collaboratorId);
                  if (!settings?.emailNotifications) {
                    continue;
                  }
                  const collaborator = await storage.getUser(collaboratorId);
                  if (collaborator?.email) {
                    await emailService.sendProjectAlert(
                      collaborator.email,
                      project.name,
                      "health_warning",
                      `Project health score is low (${insights.healthScore}%). ${insights.riskFactors.join(", ")} - Daily reminder until resolved.`
                    );
                    console.log(`\u{1F6A8} Project health alert sent for "${project.name}" to ${collaborator.email} (daily reminder)`);
                    healthAlertSentToAnyUser = true;
                  }
                }
                if (healthAlertSentToAnyUser) {
                  this.sentProjectHealthAlerts.add(healthAlertId);
                }
              }
            }
          }
          console.log("Project health check completed");
        } catch (error) {
          console.error("Project health check failed:", error);
        }
      }
    };
    scheduler = new NotificationScheduler();
  }
});

// server/routes/ai.ts
var ai_exports2 = {};
__export(ai_exports2, {
  aiRoutes: () => aiRoutes,
  handleSmartQuery: () => handleSmartQuery,
  handleVoiceBriefing: () => handleVoiceBriefing,
  handleVoiceCommand: () => handleVoiceCommand
});
async function handleVoiceCommand(req, res) {
  try {
    const { command, timestamp: timestamp2, conversationHistory } = req.body;
    const userId = req.session?.userId;
    if (!command || typeof command !== "string") {
      return res.status(400).json({
        success: false,
        error: "Voice command is required"
      });
    }
    const projects2 = await storage.getProjects(userId);
    const tasks2 = await storage.getTasks(void 0, userId);
    const result = await aiService.processVoiceCommand(command, {
      userId,
      projects: projects2,
      tasks: tasks2,
      timestamp: new Date(timestamp2 || Date.now()),
      conversationHistory: conversationHistory || []
    });
    res.json({
      success: true,
      response: result.response,
      action: result.action,
      dataModified: result.dataModified,
      data: result.data
    });
  } catch (error) {
    console.error("Voice command processing error:", error);
    res.status(500).json({
      success: false,
      error: error.message || "Failed to process voice command"
    });
  }
}
async function handleVoiceBriefing(req, res) {
  try {
    const userId = req.session?.userId;
    const projects2 = await storage.getProjects(userId);
    const tasks2 = await storage.getTasks(void 0, userId);
    const briefing = await aiService.generateVoiceBriefing(projects2, tasks2, userId);
    res.json({
      success: true,
      briefing: briefing.text,
      spokenBriefing: briefing.spokenText,
      keyPoints: briefing.keyPoints,
      urgentItems: briefing.urgentItems
    });
  } catch (error) {
    console.error("Voice briefing error:", error);
    res.status(500).json({
      success: false,
      error: error.message || "Failed to generate voice briefing"
    });
  }
}
async function handleSmartQuery(req, res) {
  try {
    const { query, context } = req.body;
    const userId = req.session?.userId;
    if (!query || typeof query !== "string") {
      return res.status(400).json({
        success: false,
        error: "Query is required"
      });
    }
    const projects2 = await storage.getProjects(userId);
    const tasks2 = await storage.getTasks(void 0, userId);
    const result = await aiService.processSmartQuery(query, {
      userId,
      projects: projects2,
      tasks: tasks2,
      context: context || {}
    });
    res.json({
      success: true,
      answer: result.answer,
      spokenAnswer: result.spokenAnswer,
      data: result.data,
      suggestions: result.suggestions
    });
  } catch (error) {
    console.error("Smart query processing error:", error);
    res.status(500).json({
      success: false,
      error: error.message || "Failed to process query"
    });
  }
}
var aiRoutes;
var init_ai2 = __esm({
  "server/routes/ai.ts"() {
    "use strict";
    init_ai();
    init_storage();
    aiRoutes = [
      { path: "/voice-command", method: "POST", handler: handleVoiceCommand },
      { path: "/voice-briefing", method: "GET", handler: handleVoiceBriefing },
      { path: "/smart-query", method: "POST", handler: handleSmartQuery }
    ];
  }
});

// server/index.ts
import express2 from "express";
import session from "express-session";

// server/routes.ts
init_storage();
init_ai();
init_schema();
init_email();
import { createServer } from "http";
import { randomBytes } from "crypto";

// server/services/analytics.ts
import OpenAI2 from "openai";
var openai2 = new OpenAI2({ apiKey: process.env.OPENAI_API_KEY });
var AdvancedAnalyticsService = class {
  async generateProjectSuccessPrediction(project, tasks2, teamMembers) {
    try {
      const projectData = {
        name: project.name,
        description: project.description || "No description",
        dueDate: project.dueDate,
        createdAt: project.createdAt,
        totalTasks: tasks2.length,
        completedTasks: tasks2.filter((t) => t.status === "completed").length,
        inProgressTasks: tasks2.filter((t) => t.status === "in_progress").length,
        overdueTasks: tasks2.filter((t) => t.dueDate && new Date(t.dueDate) < /* @__PURE__ */ new Date() && t.status !== "completed").length,
        highPriorityTasks: tasks2.filter((t) => t.priority === "high" || t.priority === "urgent").length,
        teamSize: teamMembers.length,
        averageTaskDuration: this.calculateAverageTaskDuration(tasks2),
        timeRemaining: project.dueDate ? Math.max(0, (new Date(project.dueDate).getTime() - Date.now()) / (1e3 * 60 * 60 * 24)) : null
      };
      const prompt = `Analyze this project and predict its success probability:

Project: ${projectData.name}
Description: ${projectData.description}
Due Date: ${project.dueDate || "Not set"}
Team Size: ${projectData.teamSize}
Days Remaining: ${projectData.timeRemaining || "No deadline"}

Current Status:
- Total Tasks: ${projectData.totalTasks}
- Completed: ${projectData.completedTasks}
- In Progress: ${projectData.inProgressTasks}
- Overdue: ${projectData.overdueTasks}
- High Priority: ${projectData.highPriorityTasks}
- Average Task Duration: ${projectData.averageTaskDuration} days

Provide a comprehensive analysis in JSON format with:
{
  "successProbability": <0-100 number>,
  "riskFactors": [<array of specific risk factors>],
  "recommendations": [<array of actionable recommendations>],
  "timelineConfidence": <0-100 confidence in meeting deadline>,
  "resourceUtilization": <0-100 how well resources are utilized>,
  "completionPrediction": "<ISO date string for predicted completion>",
  "criticalPath": [<array of most important tasks/areas>]
}

Consider factors like task completion rate, overdue items, team capacity, deadline pressure, and project complexity.`;
      const response = await openai2.chat.completions.create({
        model: "gpt-4o",
        // the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
        messages: [
          {
            role: "system",
            content: "You are an AI project management analyst specializing in predictive analytics. Provide detailed, data-driven insights in the exact JSON format requested."
          },
          { role: "user", content: prompt }
        ],
        response_format: { type: "json_object" },
        temperature: 0.3
      });
      const analysis = JSON.parse(response.choices[0].message.content || "{}");
      return {
        projectId: project.id,
        successProbability: Math.min(100, Math.max(0, analysis.successProbability || 50)),
        riskFactors: analysis.riskFactors || ["Insufficient data for analysis"],
        recommendations: analysis.recommendations || ["Continue monitoring project progress"],
        timelineConfidence: Math.min(100, Math.max(0, analysis.timelineConfidence || 50)),
        resourceUtilization: Math.min(100, Math.max(0, analysis.resourceUtilization || 75)),
        completionPrediction: analysis.completionPrediction || this.predictCompletionDate(project, tasks2),
        criticalPath: analysis.criticalPath || ["Task completion", "Resource allocation"]
      };
    } catch (error) {
      console.error("Project success prediction error:", error);
      return this.getDefaultPrediction(project);
    }
  }
  async analyzeWorkload(userId, tasks2, projects2) {
    try {
      const userTasks = tasks2.filter((t) => t.assigneeId === userId);
      const activeTasks = userTasks.filter((t) => t.status !== "completed");
      const taskDistribution = {
        urgent: activeTasks.filter((t) => t.priority === "urgent").length,
        high: activeTasks.filter((t) => t.priority === "high").length,
        medium: activeTasks.filter((t) => t.priority === "medium").length,
        low: activeTasks.filter((t) => t.priority === "low").length
      };
      const overdueCount = activeTasks.filter(
        (t) => t.dueDate && new Date(t.dueDate) < /* @__PURE__ */ new Date()
      ).length;
      const workloadData = {
        totalActiveTasks: activeTasks.length,
        overdueTasksCount: overdueCount,
        urgentTasks: taskDistribution.urgent,
        highPriorityTasks: taskDistribution.high,
        projectCount: projects2.length,
        completedThisWeek: this.getTasksCompletedThisWeek(userTasks),
        averageTasksPerDay: activeTasks.length / 7
      };
      const prompt = `Analyze this user's workload and assess burnout risk:

Current Workload:
- Active Tasks: ${workloadData.totalActiveTasks}
- Overdue Tasks: ${workloadData.overdueTasksCount}
- Urgent Priority: ${workloadData.urgentTasks}
- High Priority: ${workloadData.highPriorityTasks}
- Medium Priority: ${taskDistribution.medium}
- Low Priority: ${taskDistribution.low}
- Active Projects: ${workloadData.projectCount}
- Tasks Completed This Week: ${workloadData.completedThisWeek}
- Average Tasks Per Day: ${workloadData.averageTasksPerDay.toFixed(1)}

Provide workload analysis in JSON format:
{
  "burnoutRisk": "<Low|Medium|High|Critical>",
  "workloadScore": <0-100 where 100 is maximum healthy capacity>,
  "weeklyHours": <estimated weekly hours needed>,
  "recommendations": [<array of specific recommendations>],
  "optimalCapacity": <0-100 recommended workload percentage>
}

Consider factors like task volume, priority distribution, overdue items, and sustainable work pace.`;
      const response = await openai2.chat.completions.create({
        model: "gpt-4o",
        // the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
        messages: [
          {
            role: "system",
            content: "You are an AI workplace wellness analyst specializing in workload assessment and burnout prevention."
          },
          { role: "user", content: prompt }
        ],
        response_format: { type: "json_object" },
        temperature: 0.3
      });
      const analysis = JSON.parse(response.choices[0].message.content || "{}");
      return {
        userId,
        burnoutRisk: ["Low", "Medium", "High", "Critical"].includes(analysis.burnoutRisk) ? analysis.burnoutRisk : "Medium",
        workloadScore: Math.min(100, Math.max(0, analysis.workloadScore || 50)),
        weeklyHours: Math.max(0, analysis.weeklyHours || 40),
        taskDistribution,
        recommendations: analysis.recommendations || ["Monitor workload regularly"],
        optimalCapacity: Math.min(100, Math.max(0, analysis.optimalCapacity || 80))
      };
    } catch (error) {
      console.error("Workload analysis error:", error);
      return this.getDefaultWorkloadAnalysis(userId, tasks2);
    }
  }
  async optimizeResourceAllocation(projects2, tasks2, users2) {
    try {
      const userWorkloads = users2.map((user) => {
        const userTasks = tasks2.filter((t) => t.assigneeId === user.id && t.status !== "completed");
        return {
          userId: user.id,
          email: user.email,
          taskCount: userTasks.length,
          urgentTasks: userTasks.filter((t) => t.priority === "urgent").length,
          highTasks: userTasks.filter((t) => t.priority === "high").length,
          overdueCount: userTasks.filter((t) => t.dueDate && new Date(t.dueDate) < /* @__PURE__ */ new Date()).length
        };
      });
      const resourceData = {
        totalUsers: users2.length,
        totalActiveTasks: tasks2.filter((t) => t.status !== "completed").length,
        userWorkloads,
        averageTasksPerUser: userWorkloads.reduce((sum, u) => sum + u.taskCount, 0) / users2.length,
        maxWorkload: Math.max(...userWorkloads.map((u) => u.taskCount)),
        minWorkload: Math.min(...userWorkloads.map((u) => u.taskCount))
      };
      const prompt = `Analyze team resource allocation and suggest optimizations:

Team Overview:
- Total Team Members: ${resourceData.totalUsers}
- Total Active Tasks: ${resourceData.totalActiveTasks}
- Average Tasks per User: ${resourceData.averageTasksPerUser.toFixed(1)}
- Highest Workload: ${resourceData.maxWorkload} tasks
- Lowest Workload: ${resourceData.minWorkload} tasks

Individual Workloads:
${userWorkloads.map(
        (u) => `- User ${u.userId}: ${u.taskCount} tasks (${u.urgentTasks} urgent, ${u.highTasks} high, ${u.overdueCount} overdue)`
      ).join("\n")}

Provide resource optimization in JSON format:
{
  "overallocatedUsers": [<array of user IDs with too many tasks>],
  "underutilizedUsers": [<array of user IDs with capacity for more tasks>],
  "redistributionSuggestions": [
    {
      "fromUser": "<user ID>",
      "toUser": "<user ID>", 
      "reasoning": "<why this redistribution makes sense>"
    }
  ],
  "teamEfficiencyScore": <0-100 current team efficiency>,
  "bottlenecks": [<array of efficiency bottlenecks>]
}

Focus on workload balance, skill utilization, and removing bottlenecks.`;
      const response = await openai2.chat.completions.create({
        model: "gpt-4o",
        // the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
        messages: [
          {
            role: "system",
            content: "You are an AI resource optimization specialist focused on team efficiency and workload balance."
          },
          { role: "user", content: prompt }
        ],
        response_format: { type: "json_object" },
        temperature: 0.3
      });
      const analysis = JSON.parse(response.choices[0].message.content || "{}");
      return {
        overallocatedUsers: analysis.overallocatedUsers || [],
        underutilizedUsers: analysis.underutilizedUsers || [],
        redistributionSuggestions: analysis.redistributionSuggestions || [],
        teamEfficiencyScore: Math.min(100, Math.max(0, analysis.teamEfficiencyScore || 75)),
        bottlenecks: analysis.bottlenecks || ["No major bottlenecks identified"]
      };
    } catch (error) {
      console.error("Resource optimization error:", error);
      return this.getDefaultResourceOptimization();
    }
  }
  async generateProjectAnalytics(project, tasks2, historicalData) {
    const completedTasks = tasks2.filter((t) => t.status === "completed");
    const overdueTasks = tasks2.filter(
      (t) => t.dueDate && new Date(t.dueDate) < /* @__PURE__ */ new Date() && t.status !== "completed"
    );
    const completionRate = tasks2.length > 0 ? completedTasks.length / tasks2.length * 100 : 0;
    const overdueRate = tasks2.length > 0 ? overdueTasks.length / tasks2.length * 100 : 0;
    return {
      projectId: project.id,
      kpis: {
        completionRate: Math.round(completionRate),
        velocityTrend: this.calculateVelocityTrend(tasks2),
        avgTaskDuration: this.calculateAverageTaskDuration(tasks2),
        overdueRate: Math.round(overdueRate),
        teamSatisfaction: this.estimateTeamSatisfaction(tasks2)
      },
      trends: {
        productivity: this.generateProductivityTrend(),
        velocity: this.generateVelocityTrend(),
        burndown: this.generateBurndownChart(tasks2)
      },
      insights: await this.generateProjectInsights(project, tasks2)
    };
  }
  // Helper methods
  calculateAverageTaskDuration(tasks2) {
    const completedTasks = tasks2.filter((t) => t.status === "completed" && t.createdAt);
    if (completedTasks.length === 0) return 3;
    const totalDuration = completedTasks.reduce((sum, task) => {
      const created = new Date(task.createdAt);
      const completed = new Date(task.updatedAt || created);
      return sum + (completed.getTime() - created.getTime()) / (1e3 * 60 * 60 * 24);
    }, 0);
    return Math.round(totalDuration / completedTasks.length);
  }
  predictCompletionDate(project, tasks2) {
    const remaining = tasks2.filter((t) => t.status !== "completed").length;
    const avgDuration = this.calculateAverageTaskDuration(tasks2);
    const predictedDays = remaining * avgDuration;
    const completionDate = /* @__PURE__ */ new Date();
    completionDate.setDate(completionDate.getDate() + predictedDays);
    return completionDate.toISOString();
  }
  getTasksCompletedThisWeek(tasks2) {
    const weekStart = /* @__PURE__ */ new Date();
    weekStart.setDate(weekStart.getDate() - weekStart.getDay());
    weekStart.setHours(0, 0, 0, 0);
    return tasks2.filter(
      (t) => t.status === "completed" && t.updatedAt && new Date(t.updatedAt) >= weekStart
    ).length;
  }
  calculateVelocityTrend(tasks2) {
    const completedTasks = tasks2.filter((t) => t.status === "completed");
    const totalTasks = tasks2.length;
    return totalTasks > 0 ? completedTasks.length / totalTasks * 100 - 50 : 0;
  }
  estimateTeamSatisfaction(tasks2) {
    const overdueCount = tasks2.filter(
      (t) => t.dueDate && new Date(t.dueDate) < /* @__PURE__ */ new Date() && t.status !== "completed"
    ).length;
    const totalTasks = tasks2.length;
    const overdueRate = totalTasks > 0 ? overdueCount / totalTasks : 0;
    return Math.round(100 - overdueRate * 100);
  }
  generateProductivityTrend() {
    const data = [];
    for (let i = 30; i >= 0; i--) {
      const date = /* @__PURE__ */ new Date();
      date.setDate(date.getDate() - i);
      data.push({
        date: date.toISOString().split("T")[0],
        score: Math.round(75 + Math.random() * 25)
      });
    }
    return data;
  }
  generateVelocityTrend() {
    const data = [];
    for (let i = 14; i >= 0; i--) {
      const date = /* @__PURE__ */ new Date();
      date.setDate(date.getDate() - i);
      data.push({
        date: date.toISOString().split("T")[0],
        tasksCompleted: Math.round(Math.random() * 8 + 2)
      });
    }
    return data;
  }
  generateBurndownChart(tasks2) {
    const completedTasks = tasks2.filter((t) => t.status === "completed").length;
    const totalTasks = tasks2.length;
    const remainingTasks = totalTasks - completedTasks;
    const data = [];
    for (let i = 30; i >= 0; i--) {
      const date = /* @__PURE__ */ new Date();
      date.setDate(date.getDate() - i);
      const progress = (30 - i) / 30;
      const remaining = Math.max(0, Math.round(remainingTasks * (1 - progress * 0.8)));
      data.push({
        date: date.toISOString().split("T")[0],
        remainingTasks: remaining
      });
    }
    return data;
  }
  async generateProjectInsights(project, tasks2) {
    const insights = [];
    const completionRate = tasks2.length > 0 ? tasks2.filter((t) => t.status === "completed").length / tasks2.length * 100 : 0;
    const overdueCount = tasks2.filter(
      (t) => t.dueDate && new Date(t.dueDate) < /* @__PURE__ */ new Date() && t.status !== "completed"
    ).length;
    if (completionRate > 80) {
      insights.push("Project is performing exceptionally well with high completion rates");
    } else if (completionRate < 40) {
      insights.push("Project may need attention - completion rate is below optimal");
    }
    if (overdueCount > 0) {
      insights.push(`${overdueCount} tasks are overdue and require immediate attention`);
    }
    if (project.dueDate) {
      const daysRemaining = Math.ceil((new Date(project.dueDate).getTime() - Date.now()) / (1e3 * 60 * 60 * 24));
      if (daysRemaining < 7) {
        insights.push("Project deadline is approaching - consider priority adjustments");
      }
    }
    return insights.length > 0 ? insights : ["Project is progressing normally"];
  }
  // Default fallback methods
  getDefaultPrediction(project) {
    return {
      projectId: project.id,
      successProbability: 75,
      riskFactors: ["Limited historical data"],
      recommendations: ["Continue monitoring progress", "Regular team check-ins"],
      timelineConfidence: 70,
      resourceUtilization: 80,
      completionPrediction: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3).toISOString(),
      criticalPath: ["Task completion", "Resource management"]
    };
  }
  getDefaultWorkloadAnalysis(userId, tasks2) {
    const userTasks = tasks2.filter((t) => t.assigneeId === userId && t.status !== "completed");
    return {
      userId,
      burnoutRisk: userTasks.length > 15 ? "High" : userTasks.length > 8 ? "Medium" : "Low",
      workloadScore: Math.min(100, userTasks.length * 8),
      weeklyHours: Math.min(60, userTasks.length * 3),
      taskDistribution: {
        urgent: userTasks.filter((t) => t.priority === "urgent").length,
        high: userTasks.filter((t) => t.priority === "high").length,
        medium: userTasks.filter((t) => t.priority === "medium").length,
        low: userTasks.filter((t) => t.priority === "low").length
      },
      recommendations: ["Regular workload assessment", "Consider task delegation"],
      optimalCapacity: 85
    };
  }
  getDefaultResourceOptimization() {
    return {
      overallocatedUsers: [],
      underutilizedUsers: [],
      redistributionSuggestions: [],
      teamEfficiencyScore: 75,
      bottlenecks: ["No major bottlenecks identified"]
    };
  }
};
var analyticsService = new AdvancedAnalyticsService();

// server/auth.ts
import bcrypt from "bcrypt";
var AuthService = class {
  async login(credentials, storage2) {
    try {
      const user = await storage2.getUserByEmail(credentials.email);
      if (!user) {
        return null;
      }
      const isValid = await bcrypt.compare(credentials.password, user.password);
      if (!isValid) {
        return null;
      }
      return {
        id: user.id,
        name: user.name,
        email: user.email,
        username: user.username
      };
    } catch (error) {
      console.error("Login error:", error);
      return null;
    }
  }
  async register(userData, storage2) {
    try {
      const existingUser = await storage2.getUserByEmail(userData.email);
      if (existingUser) {
        throw new Error("User already exists with this email");
      }
      const saltRounds = 10;
      const hashedPassword = await bcrypt.hash(userData.password, saltRounds);
      const newUser = await storage2.createUser({
        name: userData.name,
        email: userData.email,
        username: userData.username || userData.email.split("@")[0],
        password: hashedPassword,
        role: "member"
      });
      try {
        await storage2.createUserSettings({
          userId: newUser.id,
          emailNotifications: true,
          morningBriefing: true,
          taskDeadlineAlerts: true,
          endOfDaySummary: true,
          urgentOnly: false,
          workingHoursStart: "09:00",
          workingHoursEnd: "18:00"
        });
      } catch (error) {
        console.error("Failed to create default user settings:", error);
      }
      return {
        id: newUser.id,
        name: newUser.name,
        email: newUser.email,
        username: newUser.username
      };
    } catch (error) {
      console.error("Registration error:", error);
      return null;
    }
  }
  generateSessionToken() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  }
};
var authService = new AuthService();

// server/middleware/auth.ts
function requireAuth(req, res, next) {
  if (!req.session || !req.session.userId) {
    return res.status(401).json({ error: "Authentication required" });
  }
  req.userId = req.session.userId;
  next();
}
function getUserId(req, mockUserId) {
  return req.session?.userId || req.userId || mockUserId;
}

// server/services/outlook.ts
import { Client } from "@microsoft/microsoft-graph-client";
import { ConfidentialClientApplication } from "@azure/msal-node";
import "isomorphic-fetch";
var OutlookAuthProvider = class {
  accessToken;
  constructor(accessToken) {
    this.accessToken = accessToken;
  }
  async getAccessToken() {
    return this.accessToken;
  }
};
var OutlookService = class {
  static clientApp = null;
  static initializeClientApp() {
    if (!process.env.OUTLOOK_CLIENT_ID || !process.env.OUTLOOK_CLIENT_SECRET || !process.env.OUTLOOK_TENANT_ID) {
      throw new Error("Missing Outlook OAuth configuration. Please set OUTLOOK_CLIENT_ID, OUTLOOK_CLIENT_SECRET, and OUTLOOK_TENANT_ID environment variables.");
    }
    if (!this.clientApp) {
      this.clientApp = new ConfidentialClientApplication({
        auth: {
          clientId: process.env.OUTLOOK_CLIENT_ID,
          clientSecret: process.env.OUTLOOK_CLIENT_SECRET,
          authority: `https://login.microsoftonline.com/${process.env.OUTLOOK_TENANT_ID}`
        }
      });
    }
    return this.clientApp;
  }
  static async getAuthUrl() {
    const clientApp = this.initializeClientApp();
    const authCodeUrlParameters = {
      scopes: ["https://graph.microsoft.com/Calendars.ReadWrite", "https://graph.microsoft.com/User.Read"],
      redirectUri: `${process.env.BASE_URL || "http://localhost:5000"}/api/auth/outlook/callback`
    };
    return await clientApp.getAuthCodeUrl(authCodeUrlParameters);
  }
  static async exchangeCodeForToken(code) {
    const clientApp = this.initializeClientApp();
    const tokenRequest = {
      code,
      scopes: ["https://graph.microsoft.com/Calendars.ReadWrite", "https://graph.microsoft.com/User.Read"],
      redirectUri: `${process.env.BASE_URL || "http://localhost:5000"}/api/auth/outlook/callback`
    };
    try {
      const response = await clientApp.acquireTokenByCode(tokenRequest);
      return response.accessToken;
    } catch (error) {
      throw new Error("Failed to exchange authorization code for access token");
    }
  }
  static async getCalendarEvents(accessToken, startDate, endDate) {
    const authProvider = new OutlookAuthProvider(accessToken);
    const graphClient = Client.initWithMiddleware({ authProvider });
    try {
      let requestUrl = "/me/events";
      if (startDate && endDate) {
        const startTime = startDate.toISOString();
        const endTime = endDate.toISOString();
        requestUrl += `?$filter=start/dateTime ge '${startTime}' and start/dateTime le '${endTime}'`;
      }
      requestUrl += (requestUrl.includes("?") ? "&" : "?") + "$orderby=start/dateTime&$top=100";
      const events = await graphClient.api(requestUrl).get();
      return events.value.map((event) => ({
        id: event.id,
        title: event.subject,
        description: event.bodyPreview,
        start: new Date(event.start.dateTime),
        end: new Date(event.end.dateTime),
        location: event.location?.displayName,
        attendees: event.attendees?.map((attendee) => ({
          name: attendee.emailAddress.name,
          email: attendee.emailAddress.address
        })),
        isAllDay: event.isAllDay,
        webLink: event.webLink,
        source: "outlook"
      }));
    } catch (error) {
      console.error("Error fetching Outlook calendar events:", error);
      throw new Error("Failed to fetch calendar events from Outlook");
    }
  }
  static async createCalendarEvent(accessToken, eventData) {
    const authProvider = new OutlookAuthProvider(accessToken);
    const graphClient = Client.initWithMiddleware({ authProvider });
    const event = {
      subject: eventData.title,
      body: {
        contentType: "Text",
        content: eventData.description || ""
      },
      start: {
        dateTime: eventData.start.toISOString(),
        timeZone: "UTC"
      },
      end: {
        dateTime: eventData.end.toISOString(),
        timeZone: "UTC"
      },
      location: eventData.location ? {
        displayName: eventData.location
      } : void 0,
      attendees: eventData.attendees?.map((email) => ({
        emailAddress: {
          address: email,
          name: email.split("@")[0]
        },
        type: "required"
      }))
    };
    try {
      const createdEvent = await graphClient.api("/me/events").post(event);
      return {
        id: createdEvent.id,
        title: createdEvent.subject,
        start: new Date(createdEvent.start.dateTime),
        end: new Date(createdEvent.end.dateTime),
        webLink: createdEvent.webLink
      };
    } catch (error) {
      console.error("Error creating Outlook calendar event:", error);
      throw new Error("Failed to create calendar event in Outlook");
    }
  }
  static async getUserProfile(accessToken) {
    const authProvider = new OutlookAuthProvider(accessToken);
    const graphClient = Client.initWithMiddleware({ authProvider });
    try {
      const user = await graphClient.api("/me").get();
      return {
        id: user.id,
        name: user.displayName,
        email: user.mail || user.userPrincipalName
      };
    } catch (error) {
      console.error("Error fetching user profile:", error);
      throw new Error("Failed to fetch user profile from Outlook");
    }
  }
};

// server/routes.ts
import {
  generateRegistrationOptions,
  verifyRegistrationResponse,
  generateAuthenticationOptions,
  verifyAuthenticationResponse
} from "@simplewebauthn/server";
function calculateStringSimilarity(str1, str2) {
  const len1 = str1.length;
  const len2 = str2.length;
  if (len1 === 0) return len2 === 0 ? 1 : 0;
  if (len2 === 0) return 0;
  const matrix = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));
  for (let i = 0; i <= len1; i++) matrix[i][0] = i;
  for (let j = 0; j <= len2; j++) matrix[0][j] = j;
  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j] + 1,
          // deletion
          matrix[i][j - 1] + 1,
          // insertion
          matrix[i - 1][j - 1] + 1
          // substitution
        );
      }
    }
  }
  const maxLen = Math.max(len1, len2);
  const distance = matrix[len1][len2];
  return (maxLen - distance) / maxLen;
}
async function registerRoutes(app2) {
  app2.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password } = req.body;
      if (!email || !password) {
        return res.status(400).json({ error: "Email and password are required" });
      }
      const user = await authService.login({ email, password }, storage);
      if (!user) {
        try {
          const existingUser = await storage.getUserByEmail(email);
          if (existingUser) {
            await storage.createLoginEvent({
              userId: existingUser.id,
              type: "login_failure",
              method: "password",
              deviceName: req.get("user-agent")?.includes("Mobile") ? "Mobile Device" : "Desktop",
              userAgent: req.get("user-agent") || null,
              ipAddress: req.ip || req.connection.remoteAddress || null
            });
          }
        } catch (error) {
          console.error("Failed to log failed login event:", error);
        }
        return res.status(401).json({ error: "Invalid email or password" });
      }
      req.session.userId = user.id;
      req.session.user = user;
      try {
        await storage.createLoginEvent({
          userId: user.id,
          type: "login_success",
          method: "password",
          deviceName: req.get("user-agent")?.includes("Mobile") ? "Mobile Device" : "Desktop",
          userAgent: req.get("user-agent") || null,
          ipAddress: req.ip || req.connection.remoteAddress || null
        });
      } catch (error) {
        console.error("Failed to log login event:", error);
      }
      res.json({ user, message: "Login successful" });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ error: "Login failed" });
    }
  });
  app2.post("/api/auth/register", async (req, res) => {
    try {
      const { email, password, name } = req.body;
      if (!email || !password || !name) {
        return res.status(400).json({ error: "Email, password, and name are required" });
      }
      const user = await authService.register({ email, password, name }, storage);
      if (!user) {
        return res.status(400).json({ error: "Registration failed - user may already exist" });
      }
      req.session.userId = user.id;
      req.session.user = user;
      res.status(201).json({ user, message: "Registration successful" });
    } catch (error) {
      console.error("Registration error:", error);
      res.status(500).json({ error: "Registration failed" });
    }
  });
  app2.post("/api/auth/logout", (req, res) => {
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ error: "Logout failed" });
      }
      res.json({ message: "Logout successful" });
    });
  });
  app2.get("/api/auth/me", async (req, res) => {
    if (!req.session || !req.session.userId) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    try {
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        req.session.destroy(() => {
        });
        return res.status(401).json({ error: "User not found" });
      }
      const safeUser = {
        id: user.id,
        name: user.name,
        email: user.email,
        username: user.username
      };
      res.json({ user: safeUser });
    } catch (error) {
      console.error("Auth check error:", error);
      res.status(500).json({ error: "Authentication check failed" });
    }
  });
  app2.get("/api/auth/security-analytics", async (req, res) => {
    if (!req.session || !req.session.userId) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    try {
      const analytics = await storage.getSecurityAnalytics(req.session.userId);
      res.json(analytics);
    } catch (error) {
      console.error("Security analytics error:", error);
      res.status(500).json({ error: "Failed to fetch security analytics" });
    }
  });
  app2.post("/api/auth/webauthn/register/begin", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const existingAuthenticators = await storage.getUserAuthenticators(userId);
      const options = await generateRegistrationOptions({
        rpName: "AI ProjectHub",
        rpID: req.hostname === "localhost" ? "localhost" : req.hostname,
        userID: new TextEncoder().encode(user.id),
        userName: user.email,
        userDisplayName: user.name,
        attestationType: "none",
        excludeCredentials: existingAuthenticators.map((auth) => ({
          id: auth.credentialId,
          type: "public-key",
          transports: auth.transports
        })),
        authenticatorSelection: {
          residentKey: "preferred",
          userVerification: "preferred",
          authenticatorAttachment: "platform"
          // Prefer built-in authenticators (Touch ID/Face ID)
        }
      });
      req.session.webauthnChallenge = options.challenge;
      res.json(options);
    } catch (error) {
      console.error("WebAuthn registration begin error:", error);
      res.status(500).json({ error: "Failed to start registration" });
    }
  });
  app2.post("/api/auth/webauthn/register/finish", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const { credential: registrationCredential, deviceName } = req.body;
      const expectedChallenge = req.session.webauthnChallenge;
      if (!expectedChallenge) {
        return res.status(400).json({ error: "No registration in progress" });
      }
      const verification = await verifyRegistrationResponse({
        response: registrationCredential,
        expectedChallenge,
        expectedOrigin: req.get("origin") || `${req.protocol}://${req.get("host")}`,
        expectedRPID: req.hostname === "localhost" ? "localhost" : req.hostname,
        requireUserVerification: false
      });
      if (!verification.verified || !verification.registrationInfo) {
        return res.status(400).json({ error: "Registration verification failed" });
      }
      const { credential } = verification.registrationInfo;
      const credentialID = credential.id;
      const credentialPublicKey = credential.publicKey;
      const counter = credential.counter;
      await storage.createAuthenticator({
        userId: user.id,
        credentialId: Buffer.from(credentialID).toString("base64url"),
        credentialPublicKey: Buffer.from(credentialPublicKey).toString("base64url"),
        counter,
        credentialDeviceType: "singleDevice",
        credentialBackedUp: false,
        transports: registrationCredential.response.transports,
        deviceName: deviceName || "Biometric Device"
      });
      delete req.session.webauthnChallenge;
      res.json({ verified: true, message: "Biometric authentication registered successfully" });
    } catch (error) {
      console.error("WebAuthn registration finish error:", error);
      res.status(500).json({ error: "Failed to complete registration" });
    }
  });
  app2.post("/api/auth/webauthn/login/begin", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const userAuthenticators = await storage.getUserAuthenticators(user.id);
      if (userAuthenticators.length === 0) {
        return res.status(400).json({ error: "No biometric authentication registered for this user" });
      }
      const options = await generateAuthenticationOptions({
        rpID: req.hostname === "localhost" ? "localhost" : req.hostname,
        allowCredentials: userAuthenticators.map((auth) => ({
          id: auth.credentialId,
          type: "public-key",
          transports: auth.transports
        })),
        userVerification: "preferred"
      });
      req.session.webauthnChallenge = options.challenge;
      req.session.webauthnUserId = user.id;
      res.json(options);
    } catch (error) {
      console.error("WebAuthn authentication begin error:", error);
      res.status(500).json({ error: "Failed to start authentication" });
    }
  });
  app2.post("/api/auth/webauthn/login/finish", async (req, res) => {
    try {
      const { credential } = req.body;
      const expectedChallenge = req.session.webauthnChallenge;
      const userId = req.session.webauthnUserId;
      if (!expectedChallenge || !userId) {
        return res.status(400).json({ error: "No authentication in progress" });
      }
      const authenticator = await storage.getAuthenticatorByCredentialId(
        Buffer.from(credential.id, "base64url").toString("base64url")
      );
      if (!authenticator || authenticator.userId !== userId) {
        return res.status(400).json({ error: "Authenticator not found" });
      }
      const verification = await verifyAuthenticationResponse({
        response: credential,
        expectedChallenge,
        expectedOrigin: req.get("origin") || `${req.protocol}://${req.get("host")}`,
        expectedRPID: req.hostname === "localhost" ? "localhost" : req.hostname,
        credential: {
          id: authenticator.credentialId,
          publicKey: Buffer.from(authenticator.credentialPublicKey, "base64url"),
          counter: authenticator.counter
        },
        requireUserVerification: false
      });
      if (!verification.verified) {
        try {
          if (authenticator) {
            await storage.createLoginEvent({
              userId: authenticator.userId,
              type: "biometric_failure",
              method: "biometric",
              deviceName: authenticator.deviceName || (req.get("user-agent")?.includes("Mobile") ? "Mobile Device" : "Desktop"),
              userAgent: req.get("user-agent") || null,
              ipAddress: req.ip || req.connection.remoteAddress || null
            });
          }
        } catch (error) {
          console.error("Failed to log biometric failure event:", error);
        }
        return res.status(400).json({ error: "Authentication verification failed" });
      }
      await storage.updateAuthenticator(authenticator.credentialId, {
        counter: verification.authenticationInfo.newCounter
      });
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      req.session.userId = user.id;
      req.session.user = user;
      try {
        await storage.createLoginEvent({
          userId: user.id,
          type: "biometric_login",
          method: "biometric",
          deviceName: authenticator.deviceName || (req.get("user-agent")?.includes("Mobile") ? "Mobile Device" : "Desktop"),
          userAgent: req.get("user-agent") || null,
          ipAddress: req.ip || req.connection.remoteAddress || null
        });
      } catch (error) {
        console.error("Failed to log biometric login event:", error);
      }
      delete req.session.webauthnChallenge;
      delete req.session.webauthnUserId;
      res.json({
        verified: true,
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          username: user.username
        },
        message: "Biometric authentication successful"
      });
    } catch (error) {
      console.error("WebAuthn authentication finish error:", error);
      res.status(500).json({ error: "Failed to complete authentication" });
    }
  });
  app2.get("/api/auth/webauthn/authenticators", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const authenticators2 = await storage.getUserAuthenticators(userId);
      const safeAuthenticators = authenticators2.map((auth) => ({
        id: auth.credentialId,
        // Use credentialId as the identifier for deletion
        deviceName: auth.deviceName,
        createdAt: auth.createdAt,
        lastUsedAt: auth.lastUsedAt
      }));
      res.json(safeAuthenticators);
    } catch (error) {
      console.error("Get authenticators error:", error);
      res.status(500).json({ error: "Failed to get authenticators" });
    }
  });
  app2.delete("/api/auth/webauthn/authenticators/:credentialId", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const { credentialId } = req.params;
      const authenticator = await storage.getAuthenticatorByCredentialId(credentialId);
      if (!authenticator || authenticator.userId !== userId) {
        return res.status(404).json({ error: "Authenticator not found" });
      }
      await storage.deleteAuthenticator(credentialId);
      res.json({ message: "Authenticator deleted successfully" });
    } catch (error) {
      console.error("Delete authenticator error:", error);
      res.status(500).json({ error: "Failed to delete authenticator" });
    }
  });
  const mockUserId = "9a002ca6-ee3c-4ebb-953f-c602fdb3ecbd";
  app2.get("/api/settings", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      let settings = await storage.getUserSettings(userId);
      if (!settings) {
        const defaultSettings = {
          userId,
          emailNotifications: true,
          morningBriefing: true,
          lunchReminder: false,
          endOfDaySummary: true,
          meetingReminders: true,
          taskDeadlineAlerts: true,
          aiInsights: true,
          workingHoursStart: "09:00",
          workingHoursEnd: "18:00",
          urgentOnly: false
        };
        settings = await storage.createUserSettings(defaultSettings);
      }
      res.json(settings);
    } catch (error) {
      console.error("Error fetching settings:", error);
      res.status(500).json({ message: "Failed to fetch settings" });
    }
  });
  app2.put("/api/profile", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const { email, name } = req.body;
      if (!email || !name) {
        return res.status(400).json({ error: "Email and name are required" });
      }
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        return res.status(400).json({ error: "Invalid email format" });
      }
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser && existingUser.id !== userId) {
        return res.status(400).json({ error: "Email is already in use by another account" });
      }
      const updatedUser = await storage.updateUser(userId, { email, name });
      req.session.user = {
        id: updatedUser.id,
        name: updatedUser.name,
        email: updatedUser.email,
        username: updatedUser.username
      };
      res.json({
        user: req.session.user,
        message: "Profile updated successfully"
      });
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ error: "Failed to update profile" });
    }
  });
  app2.put("/api/settings", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const updatedSettings = await storage.updateUserSettings(userId, req.body);
      res.json(updatedSettings);
    } catch (error) {
      console.error("Error updating settings:", error);
      res.status(500).json({ message: "Failed to update settings" });
    }
  });
  app2.post("/api/settings/test-email", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const user = await storage.getUser(userId);
      const settings = await storage.getUserSettings(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      if (!settings?.emailNotifications) {
        return res.status(400).json({
          message: "Email notifications are disabled. Please enable them in settings first."
        });
      }
      console.log(`\u{1F4E7} Sending test email to: ${user.email}`);
      await emailService.sendTestEmail(user.email);
      console.log(`\u2705 Test email sent successfully to: ${user.email}`);
      res.json({
        message: "Test email sent successfully",
        sentTo: user.email
      });
    } catch (error) {
      console.error("\u274C Error sending test email:", error);
      res.status(500).json({
        message: "Failed to send test email",
        error: error.message
      });
    }
  });
  app2.get("/api/dashboard/stats", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const stats = await storage.getDashboardStats(userId);
      res.json(stats);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch dashboard stats" });
    }
  });
  app2.get("/api/dashboard/activity", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const limit = parseInt(req.query.limit) || 10;
      const activity = await storage.getRecentActivity(userId, limit);
      res.json(activity);
    } catch (error) {
      console.error("Recent activity error:", error);
      res.status(500).json({ message: "Failed to fetch recent activity" });
    }
  });
  app2.get("/api/dashboard/todays-meetings", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const meetings2 = await storage.getTodaysMeetings(userId);
      res.json(meetings2);
    } catch (error) {
      console.error("Today's meetings error:", error);
      res.status(500).json({ message: "Failed to fetch today's meetings" });
    }
  });
  app2.get("/api/projects", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projects2 = await storage.getProjects(userId);
      const projectsWithTaskCounts = await Promise.all(
        projects2.map(async (project) => {
          const allTasks = await storage.getTasks(project.id);
          const myTasks = allTasks.filter((task) => task.assigneeId === userId);
          const completedTasks = allTasks.filter((task) => task.status === "completed").length;
          const actualProgress = allTasks.length > 0 ? Math.round(completedTasks / allTasks.length * 100) : 0;
          return {
            ...project,
            totalTasks: allTasks.length,
            completedTasks,
            myTasks: myTasks.length,
            actualProgress,
            isOwner: project.ownerId === userId
            // Add ownership flag
          };
        })
      );
      res.json(projectsWithTaskCounts);
    } catch (error) {
      console.error("Failed to fetch projects:", error);
      res.status(500).json({ message: "Failed to fetch projects" });
    }
  });
  app2.post("/api/projects", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projectData = insertProjectSchema.parse({ ...req.body, ownerId: userId });
      const project = await storage.createProject(projectData);
      res.json(project);
    } catch (error) {
      console.error("Project creation error:", error);
      res.status(400).json({ message: "Invalid project data", error: error.message });
    }
  });
  app2.get("/api/projects/:id", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const project = await storage.getProject(req.params.id);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      const userProjects = await storage.getProjects(userId);
      const hasAccess = userProjects.some((p) => p.id === project.id);
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }
      res.json(project);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch project" });
    }
  });
  app2.get("/api/projects/:id/tasks", requireAuth, async (req, res) => {
    try {
      const tasks2 = await storage.getTasksByProject(req.params.id);
      res.json(tasks2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch project tasks" });
    }
  });
  app2.put("/api/projects/:id", requireAuth, async (req, res) => {
    try {
      const updates = insertProjectSchema.partial().parse(req.body);
      const project = await storage.updateProject(req.params.id, updates);
      res.json(project);
    } catch (error) {
      console.error("Project update error:", error);
      res.status(400).json({ message: "Invalid project data", error: error.message });
    }
  });
  app2.delete("/api/projects/:id", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projectId = req.params.id;
      const project = await storage.getProject(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      if (project.ownerId !== userId) {
        return res.status(403).json({ message: "Only project owner can delete this project" });
      }
      await storage.deleteProject(projectId);
      res.json({ message: "Project and all associated data deleted successfully" });
    } catch (error) {
      console.error("Project deletion error:", error);
      res.status(500).json({
        message: "Failed to delete project",
        error: error.message || "Unknown error occurred"
      });
    }
  });
  app2.get("/api/project-members", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const userProjects = await storage.getProjects(userId);
      const allMembers = [];
      for (const project of userProjects) {
        const members = await storage.getProjectMembers(project.id);
        allMembers.push(...members);
        const owner = await storage.getUser(project.ownerId);
        if (owner) {
          const ownerAlreadyInList = members.some((member) => member.userId === owner.id);
          if (!ownerAlreadyInList) {
            allMembers.push({
              id: `owner-${project.id}`,
              // Unique ID for owner entry
              projectId: project.id,
              userId: owner.id,
              role: "owner",
              joinedAt: project.createdAt,
              // Use project creation date as join date
              user: owner
            });
          }
        }
      }
      res.json(allMembers);
    } catch (error) {
      console.error("Failed to fetch all project members:", error);
      res.status(500).json({ message: "Failed to fetch project members" });
    }
  });
  app2.get("/api/projects/:id/members", requireAuth, async (req, res) => {
    try {
      const members = await storage.getProjectMembers(req.params.id);
      res.json(members);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch project members" });
    }
  });
  app2.post("/api/projects/:id/invite", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const { email, role = "member" } = req.body;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        return res.status(400).json({ message: "Invalid email format" });
      }
      const project = await storage.getProject(req.params.id);
      if (!project || project.ownerId !== userId) {
        return res.status(403).json({ message: "Only project owners can invite members" });
      }
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        const existingMembers = await storage.getProjectMembers(req.params.id);
        const isAlreadyMember = existingMembers.some((m) => m.userId === existingUser.id);
        const isOwner = project.ownerId === existingUser.id;
        if (isOwner) {
          return res.status(400).json({ message: "User is already the project owner" });
        }
        if (isAlreadyMember) {
          return res.status(400).json({ message: "User is already a project member" });
        }
      }
      const existingInvitations = await storage.getInvitationsByProject(req.params.id);
      const pendingInvitation = existingInvitations.find(
        (inv) => inv.inviteeEmail === email && inv.status === "pending"
      );
      if (pendingInvitation) {
        return res.status(400).json({ message: "Invitation already sent to this email" });
      }
      const inviter = await storage.getUser(userId);
      if (!inviter) {
        return res.status(400).json({ message: "Inviter not found" });
      }
      const token = randomBytes(32).toString("hex");
      const expiresAt = /* @__PURE__ */ new Date();
      expiresAt.setDate(expiresAt.getDate() + 7);
      const invitation = await storage.createInvitation({
        projectId: req.params.id,
        inviterUserId: userId,
        inviteeEmail: email,
        role,
        token,
        expiresAt
      });
      if (existingUser) {
        await storage.createNotification({
          userId: existingUser.id,
          title: "Project Invitation",
          message: `${inviter.name} invited you to join "${project.name}" as a ${role}`,
          type: "invitation",
          data: {
            invitationId: invitation.id,
            projectId: req.params.id,
            projectName: project.name,
            inviterName: inviter.name,
            role,
            token
          }
        });
      }
      try {
        await emailService.sendProjectInvitation(
          email,
          project.name,
          inviter.name,
          token,
          role
        );
      } catch (emailError) {
        console.error("Failed to send invitation email:", emailError);
      }
      res.json({
        message: "Invitation sent successfully",
        invitation: {
          id: invitation.id,
          email,
          role,
          projectName: project.name,
          status: invitation.status,
          expiresAt: invitation.expiresAt
        }
      });
    } catch (error) {
      console.error("Invite member error:", error);
      res.status(500).json({ message: "Failed to send invitation", error: error.message });
    }
  });
  app2.delete("/api/projects/:id/members/:userId", requireAuth, async (req, res) => {
    try {
      const currentUserId = getUserId(req, mockUserId);
      const project = await storage.getProject(req.params.id);
      if (!project || project.ownerId !== currentUserId) {
        return res.status(403).json({ message: "Only project owners can remove members" });
      }
      await storage.removeProjectMember(req.params.id, req.params.userId);
      res.json({ message: "Member removed successfully" });
    } catch (error) {
      res.status(500).json({ message: "Failed to remove member" });
    }
  });
  app2.get("/api/ai/project-insights/:id", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const project = await storage.getProject(req.params.id);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      const userProjects = await storage.getProjects(userId);
      const hasAccess = userProjects.some((p) => p.id === req.params.id);
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied to this project" });
      }
      const tasks2 = await storage.getTasksByProject(req.params.id);
      const insights = await aiService.generateProjectInsights(project, tasks2);
      res.json(insights);
    } catch (error) {
      console.error("AI insights error:", error);
      res.status(500).json({ message: "Failed to generate insights", error: error.message });
    }
  });
  app2.get("/api/ai/notifications", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projects2 = await storage.getProjects(userId);
      const tasks2 = await storage.getTasks(void 0, userId);
      const notifications2 = await aiService.generateSmartNotifications(projects2, tasks2, userId);
      res.json(notifications2);
    } catch (error) {
      console.error("Smart notifications error:", error);
      res.status(500).json({ message: "Failed to generate notifications", error: error.message });
    }
  });
  app2.get("/api/ai/daily-summary", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projects2 = await storage.getProjects(userId);
      const tasks2 = await storage.getTasks(void 0, userId);
      const summary = await aiService.generateDailySummary(projects2, tasks2, userId);
      res.json(summary);
    } catch (error) {
      console.error("Daily summary error:", error);
      res.status(500).json({ message: "Failed to generate daily summary", error: error.message });
    }
  });
  app2.post("/api/ai/send-notification-email", async (req, res) => {
    try {
      const { type, email = "user@example.com", data } = req.body;
      if (type === "daily_summary") {
        const projects2 = await storage.getProjects(mockUserId);
        const tasks2 = await storage.getTasks();
        const summary = await aiService.generateDailySummary(projects2, tasks2, mockUserId);
        await emailService.sendDailySummary(email, summary);
        res.json({
          message: "Daily summary email sent",
          summary,
          emailSent: !!process.env.RESEND_API_KEY,
          note: !process.env.RESEND_API_KEY ? "Email logged to console (Resend API key not configured)" : "Email sent via Resend"
        });
      } else if (type === "test_email") {
        await emailService.sendTestEmail(email);
        res.json({
          message: "Test email sent",
          emailSent: !!process.env.RESEND_API_KEY,
          note: !process.env.RESEND_API_KEY ? "Email logged to console (Resend API key not configured)" : "Email sent via Resend"
        });
      } else if (type === "project_alert" && data) {
        await emailService.sendProjectAlert(email, data.projectName, data.alertType, data.message);
        res.json({
          message: "Project alert email sent",
          emailSent: !!process.env.RESEND_API_KEY
        });
      } else if (type === "deadline_alert" && data) {
        await emailService.sendTaskDeadlineAlert(email, data.taskTitle, data.projectName, data.dueDate);
        res.json({
          message: "Deadline alert email sent",
          emailSent: !!process.env.RESEND_API_KEY
        });
      } else {
        res.status(400).json({ message: "Invalid notification type or missing data" });
      }
    } catch (error) {
      console.error("Email notification error:", error);
      res.status(500).json({ message: "Failed to send notification email", error: error.message });
    }
  });
  app2.post("/api/ai/notify-project-members/:projectId", async (req, res) => {
    try {
      const { type, message } = req.body;
      const projectId = req.params.projectId;
      const project = await storage.getProject(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      const projectMembers2 = await storage.getProjectMembers(projectId);
      const owner = await storage.getUser(project.ownerId);
      const memberEmails = [];
      if (owner?.email) {
        memberEmails.push(owner.email);
      }
      for (const member of projectMembers2) {
        const memberUser = await storage.getUser(member.userId);
        if (memberUser?.email && !memberEmails.includes(memberUser.email)) {
          memberEmails.push(memberUser.email);
        }
      }
      const tasks2 = await storage.getTasksByProject(projectId);
      const insights = await aiService.generateProjectInsights(project, tasks2);
      const emailPromises = memberEmails.map((email) => {
        if (type === "health_alert") {
          return emailService.sendProjectAlert(
            email,
            project.name,
            insights.healthScore < 40 ? "urgent" : "high",
            message || `Project health score is ${insights.healthScore}%. ${insights.riskFactors[0] || "Needs attention"}`
          );
        } else if (type === "deadline_reminder") {
          const upcomingTasks = tasks2.filter(
            (t) => t.dueDate && new Date(t.dueDate) > /* @__PURE__ */ new Date() && new Date(t.dueDate) <= new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3)
          );
          return Promise.all(upcomingTasks.map(
            (task) => emailService.sendTaskDeadlineAlert(email, task.title, project.name, task.dueDate.toString())
          ));
        }
        return Promise.resolve();
      });
      await Promise.all(emailPromises);
      res.json({
        message: `Notifications sent to ${memberEmails.length} project members`,
        projectName: project.name,
        emailsSent: !!process.env.RESEND_API_KEY,
        recipients: memberEmails
      });
    } catch (error) {
      console.error("Project member notification error:", error);
      res.status(500).json({ message: "Failed to notify project members", error: error.message });
    }
  });
  app2.get("/api/tasks", requireAuth, async (req, res) => {
    try {
      const { projectId } = req.query;
      const userId = getUserId(req, "");
      if (projectId) {
        const tasks2 = await storage.getTasks(projectId, userId);
        res.json(tasks2);
      } else {
        const userProjects = await storage.getProjects(userId);
        const allTasks = [];
        for (const project of userProjects) {
          const projectTasks = await storage.getTasks(project.id);
          allTasks.push(...projectTasks);
        }
        allTasks.sort((a, b) => {
          const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
          const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
          return dateB - dateA;
        });
        res.json(allTasks);
      }
    } catch (error) {
      console.error("Error fetching tasks:", error);
      res.status(500).json({ message: "Failed to fetch tasks" });
    }
  });
  app2.post("/api/tasks", requireAuth, async (req, res) => {
    try {
      const taskData = insertTaskSchema.parse(req.body);
      const task = await storage.createTask(taskData);
      res.json(task);
    } catch (error) {
      console.error("Task creation error:", error);
      res.status(400).json({ message: "Invalid task data", error: error.message });
    }
  });
  app2.put("/api/tasks/:id", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const updates = insertTaskSchema.partial().parse(req.body);
      const task = await storage.updateTask(req.params.id, updates, userId);
      res.json(task);
    } catch (error) {
      res.status(400).json({ message: "Invalid task data" });
    }
  });
  app2.delete("/api/tasks/:id", requireAuth, async (req, res) => {
    try {
      await storage.deleteTask(req.params.id);
      res.json({ message: "Task deleted successfully" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete task" });
    }
  });
  app2.post("/api/tasks/batch-delete", requireAuth, async (req, res) => {
    try {
      const { taskIds } = req.body;
      if (!Array.isArray(taskIds) || taskIds.length === 0) {
        return res.status(400).json({ message: "Task IDs array is required" });
      }
      await storage.deleteTasks(taskIds);
      res.json({
        message: `${taskIds.length} tasks deleted successfully`,
        deletedCount: taskIds.length,
        taskIds
      });
    } catch (error) {
      console.error("Batch delete tasks error:", error);
      res.status(500).json({
        message: "Failed to delete tasks",
        error: error.message
      });
    }
  });
  app2.post("/api/projects/:id/recalculate-progress", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projectId = req.params.id;
      const userProjects = await storage.getProjects(userId);
      const hasAccess = userProjects.some((p) => p.id === projectId);
      if (!hasAccess) {
        return res.status(403).json({ message: "Not authorized to access this project" });
      }
      await storage.updateProjectProgress(projectId);
      const updatedProject = await storage.getProject(projectId);
      res.json({
        message: "Progress recalculated successfully",
        progress: updatedProject?.progress || 0
      });
    } catch (error) {
      console.error("Progress recalculation error:", error);
      res.status(500).json({ message: "Failed to recalculate progress", error: error.message });
    }
  });
  app2.post("/api/projects/recalculate-all-progress", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const userProjects = await storage.getProjects(userId);
      let updated = 0;
      for (const project of userProjects) {
        await storage.updateProjectProgress(project.id);
        updated++;
      }
      res.json({
        message: `Progress recalculated for ${updated} projects`,
        projectsUpdated: updated
      });
    } catch (error) {
      console.error("Bulk progress recalculation error:", error);
      res.status(500).json({ message: "Failed to recalculate progress", error: error.message });
    }
  });
  app2.get("/api/meetings", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const { projectId } = req.query;
      const meetings2 = await storage.getMeetings(userId, projectId);
      const fixedMeetings = meetings2.map((meeting) => ({
        ...meeting,
        scheduledAt: meeting.scheduledAt.toISOString()
      }));
      res.json(fixedMeetings);
    } catch (error) {
      console.error("Failed to fetch meetings:", error);
      res.status(500).json({ message: "Failed to fetch meetings" });
    }
  });
  app2.post("/api/meetings", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      if (req.body.recordingId) {
        const existingMeetings = await storage.getMeetings(userId);
        const duplicateMeeting = existingMeetings.find(
          (meeting2) => meeting2.description && meeting2.description.includes(`(ID: ${req.body.recordingId})`)
        );
        if (duplicateMeeting) {
          return res.json(duplicateMeeting);
        }
      }
      const meetingData = {
        ...req.body,
        createdById: userId,
        scheduledAt: req.body.scheduledAt ? new Date(req.body.scheduledAt) : /* @__PURE__ */ new Date()
      };
      delete meetingData.recordingId;
      const meeting = await storage.createMeeting(meetingData);
      res.json(meeting);
    } catch (error) {
      console.error("Meeting creation error:", error);
      res.status(400).json({ message: "Invalid meeting data", error: error.message });
    }
  });
  app2.get("/api/external-meetings", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const { projectId } = req.query;
      const meetings2 = await storage.getExternalMeetings(userId, projectId);
      const fixedMeetings = meetings2.map((meeting) => ({
        ...meeting,
        startTime: meeting.startTime.toISOString(),
        endTime: meeting.endTime.toISOString(),
        createdAt: meeting.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: meeting.updatedAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString()
      }));
      res.json(fixedMeetings);
    } catch (error) {
      console.error("Failed to fetch external meetings:", error);
      res.status(500).json({ message: "Failed to fetch external meetings" });
    }
  });
  app2.post("/api/external-meetings", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const meetingData = {
        ...req.body,
        userId,
        startTime: new Date(req.body.startTime),
        endTime: new Date(req.body.endTime)
      };
      const meeting = await storage.createExternalMeeting(meetingData);
      res.json(meeting);
    } catch (error) {
      console.error("External meeting creation error:", error);
      res.status(400).json({ message: "Invalid external meeting data", error: error.message });
    }
  });
  app2.put("/api/external-meetings/:id/link-project", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const meetingIdOrExternalId = req.params.id;
      const { projectId, meetingData } = req.body;
      let meeting;
      if (meetingIdOrExternalId.startsWith("outlook-")) {
        const externalId = meetingIdOrExternalId.replace("outlook-", "");
        meeting = await storage.getExternalMeetingByExternalId(externalId, userId);
        if (!meeting && meetingData) {
          meeting = await storage.createExternalMeeting({
            userId,
            externalId,
            title: meetingData.title,
            description: meetingData.description || "",
            startTime: new Date(meetingData.startTime),
            endTime: new Date(meetingData.endTime),
            location: meetingData.location || "",
            source: "outlook",
            projectId: null
            // Will be set below
          });
        } else if (!meeting) {
          return res.status(400).json({ message: "Meeting data is required to link Outlook meetings" });
        }
      } else {
        meeting = await storage.getExternalMeeting(meetingIdOrExternalId);
        if (!meeting) {
          return res.status(404).json({ message: "External meeting not found" });
        }
      }
      if (!meeting) {
        return res.status(404).json({ message: "Meeting not found" });
      }
      if (meeting.userId !== userId) {
        return res.status(403).json({ message: "Not authorized to modify this meeting" });
      }
      if (projectId) {
        const project = await storage.getProject(projectId);
        if (!project) {
          return res.status(404).json({ message: "Project not found" });
        }
        const userProjects = await storage.getProjects(userId);
        const hasAccess = userProjects.some((p) => p.id === projectId);
        if (!hasAccess) {
          return res.status(403).json({ message: "Not authorized to link to this project" });
        }
      }
      const updatedMeeting = await storage.linkExternalMeetingToProject(meeting.id, projectId);
      const cacheKey = `${userId}-`;
      let updatedCache = false;
      let projectName;
      if (updatedMeeting.projectId) {
        try {
          const project = await storage.getProject(updatedMeeting.projectId);
          projectName = project?.name;
          console.log(`\u{1F4C2} Fetched project name: "${projectName}" for projectId: ${updatedMeeting.projectId}`);
        } catch (error) {
          console.error("Error fetching project name:", error);
        }
      }
      outlookEventCache.forEach((cacheData, key) => {
        if (key.startsWith(cacheKey)) {
          const updatedEvents = cacheData.events.map((event) => {
            if (event.id === updatedMeeting.externalId) {
              console.log(`\u{1F4DD} Updating cached event "${event.title}" with projectId: ${updatedMeeting.projectId}, projectName: "${projectName}"`);
              return {
                ...event,
                projectId: updatedMeeting.projectId,
                projectName,
                dbId: updatedMeeting.id
              };
            }
            return event;
          });
          outlookEventCache.set(key, {
            events: updatedEvents,
            timestamp: cacheData.timestamp
          });
          updatedCache = true;
          console.log(`\u2705 Cache updated for key: ${key}`);
        }
      });
      if (!updatedCache) {
        console.log(`\u26A0\uFE0F No cache found to update, clearing cache to force fresh fetch`);
        const keysToDelete = [];
        outlookEventCache.forEach((value, key) => {
          if (key.startsWith(cacheKey)) {
            keysToDelete.push(key);
          }
        });
        keysToDelete.forEach((key) => {
          outlookEventCache.delete(key);
          console.log(`\u{1F5D1}\uFE0F Deleted stale cache key: ${key}`);
        });
      }
      res.json(updatedMeeting);
    } catch (error) {
      console.error("Failed to link external meeting to project:", error);
      res.status(500).json({ message: "Failed to link meeting to project", error: error.message });
    }
  });
  app2.delete("/api/external-meetings/:id", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const meetingId = req.params.id;
      const meeting = await storage.getExternalMeeting(meetingId);
      if (!meeting) {
        return res.status(404).json({ message: "External meeting not found" });
      }
      if (meeting.userId !== userId) {
        return res.status(403).json({ message: "Not authorized to delete this meeting" });
      }
      await storage.deleteExternalMeeting(meetingId);
      res.json({ message: "External meeting deleted successfully" });
    } catch (error) {
      console.error("Failed to delete external meeting:", error);
      res.status(500).json({ message: "Failed to delete external meeting", error: error.message });
    }
  });
  app2.put("/api/meetings/:id", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, "");
      const meetingId = req.params.id;
      const meeting = await storage.getMeeting(meetingId);
      if (!meeting) {
        return res.status(404).json({ message: "Meeting not found" });
      }
      if (meeting.createdById !== userId) {
        return res.status(403).json({ message: "Not authorized to update this meeting" });
      }
      const updateData = {
        ...req.body,
        scheduledAt: req.body.scheduledAt ? new Date(req.body.scheduledAt) : void 0
      };
      const updatedMeeting = await storage.updateMeeting(meetingId, updateData);
      res.json(updatedMeeting);
    } catch (error) {
      console.error("Failed to update meeting:", error);
      res.status(500).json({ message: "Failed to update meeting", error: error.message });
    }
  });
  app2.delete("/api/meetings/batch", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, "");
      const { meetingIds } = req.body;
      if (!meetingIds || !Array.isArray(meetingIds) || meetingIds.length === 0) {
        return res.status(400).json({ message: "Meeting IDs are required" });
      }
      const meetings2 = await Promise.all(
        meetingIds.map(async (id) => {
          try {
            return await storage.getMeeting(id);
          } catch {
            return null;
          }
        })
      );
      const validMeetings = meetings2.filter(
        (meeting) => meeting && meeting.createdById === userId
      );
      if (validMeetings.length === 0) {
        return res.status(404).json({ message: "No valid meetings found to delete" });
      }
      await Promise.all(
        validMeetings.map((meeting) => meeting && storage.deleteMeeting(meeting.id))
      );
      res.json({
        message: `Successfully deleted ${validMeetings.length} meeting(s)`,
        deletedCount: validMeetings.length,
        requestedCount: meetingIds.length
      });
    } catch (error) {
      console.error("Batch delete meetings error:", error);
      res.status(500).json({
        message: "Failed to delete meetings",
        error: error.message
      });
    }
  });
  app2.delete("/api/meetings/:id", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, "");
      const meetingId = req.params.id;
      const meeting = await storage.getMeeting(meetingId);
      if (!meeting) {
        return res.status(404).json({ message: "Meeting not found" });
      }
      if (meeting.createdById !== userId) {
        return res.status(403).json({ message: "Not authorized to delete this meeting" });
      }
      await storage.deleteMeeting(meetingId);
      res.json({ message: "Meeting deleted successfully" });
    } catch (error) {
      console.error("Failed to delete meeting:", error);
      res.status(500).json({ message: "Failed to delete meeting" });
    }
  });
  app2.post("/api/meetings/:id/process-recording", requireAuth, async (req, res) => {
    try {
      const { audioData, projectId } = req.body;
      const meetingId = req.params.id;
      const userId = getUserId(req, mockUserId);
      console.log(`\u{1F399}\uFE0F Processing voice recording for user ${userId}, meeting ${meetingId}`);
      console.log(`Audio data received: ${audioData ? `${audioData.length} characters` : "null/undefined"}`);
      console.log(`Audio data type: ${typeof audioData}`);
      console.log(`Request body keys: ${Object.keys(req.body)}`);
      console.log(`Request content length: ${req.get("content-length")}`);
      console.log(`Request timestamp: ${(/* @__PURE__ */ new Date()).toISOString()}`);
      if (!audioData) {
        console.error(`\u274C No audio data provided for meeting ${meetingId}`);
        return res.status(400).json({
          message: "No audio data provided",
          diagnostics: {
            bodyKeys: Object.keys(req.body),
            contentLength: req.get("content-length"),
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        });
      }
      if (typeof audioData !== "string" || audioData.length === 0) {
        console.error(`\u274C Invalid audio data format for meeting ${meetingId}: type=${typeof audioData}, length=${audioData?.length}`);
        return res.status(400).json({
          message: "Invalid audio data format",
          diagnostics: {
            dataType: typeof audioData,
            dataLength: audioData?.length,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        });
      }
      const existingMeeting = await storage.getMeeting(meetingId);
      if (existingMeeting && existingMeeting.transcription && existingMeeting.transcription.trim().length > 0) {
        console.log(`\u23ED\uFE0F Meeting ${meetingId} already processed - returning existing data without reprocessing`);
        console.log(`\u2705 Preventing duplicate email notification for meeting "${existingMeeting.title}"`);
        return res.json({
          success: true,
          meeting: existingMeeting,
          tasksCreated: Array.isArray(existingMeeting.extractedTasks) ? existingMeeting.extractedTasks.length : 0,
          extractedTasks: existingMeeting.extractedTasks || [],
          transcription: existingMeeting.transcription,
          aiSummary: existingMeeting.aiSummary,
          alreadyProcessed: true
          // Flag to indicate this was already processed
        });
      }
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("Recording processing timeout - file may be too large")), 9e5);
      });
      console.log("Using AssemblyAI for professional mobile transcription...");
      const { transcriptionService: ts } = await Promise.resolve().then(() => (init_transcription(), transcription_exports));
      const transcriptionResult = await Promise.race([
        ts.transcribeAudio(audioData),
        timeoutPromise
      ]);
      const transcription = transcriptionResult.text;
      if (!transcription || transcription.trim().length === 0) {
        return res.status(400).json({ message: "No transcription generated from audio" });
      }
      const extractedTasks = await aiService.extractTasksFromText(transcription);
      const summary = await aiService.generateMeetingSummary(transcription);
      const meeting = await storage.updateMeeting(meetingId, {
        transcription,
        aiSummary: summary,
        extractedTasks
      });
      let createdTasks = [];
      if (projectId && extractedTasks && extractedTasks.length > 0) {
        const existingTasks = await storage.getTasks(projectId);
        for (const taskData of extractedTasks) {
          const isDuplicate = existingTasks.some((existingTask) => {
            if (existingTask.title.toLowerCase().trim() === taskData.title.toLowerCase().trim()) {
              return true;
            }
            const similarity = calculateStringSimilarity(
              existingTask.title.toLowerCase(),
              taskData.title.toLowerCase()
            );
            if (similarity > 0.8) {
              return true;
            }
            if (existingTask.description && taskData.description) {
              const descSimilarity = calculateStringSimilarity(
                existingTask.description.toLowerCase(),
                taskData.description.toLowerCase()
              );
              if (descSimilarity > 0.85) {
                return true;
              }
            }
            return false;
          });
          if (isDuplicate) {
            console.log(`\u23ED\uFE0F Skipping duplicate task: "${taskData.title}"`);
            continue;
          }
          let dueDate = null;
          if (taskData.dueDate && !isNaN(Date.parse(taskData.dueDate))) {
            dueDate = new Date(taskData.dueDate);
          } else {
            dueDate = /* @__PURE__ */ new Date();
            dueDate.setDate(dueDate.getDate() + 7);
          }
          const task = await storage.createTask({
            title: taskData.title,
            description: taskData.description || taskData.title,
            projectId,
            priority: taskData.priority || "medium",
            assigneeId: userId,
            dueDate
          });
          createdTasks.push(task);
          console.log(`\u2705 Created new task: "${taskData.title}"`);
        }
        const project = await storage.getProject(projectId);
        const user = await storage.getUser(userId);
        if (project && user?.email) {
          try {
            await emailService.sendMeetingProcessedNotification(
              user.email,
              meeting.title || "Meeting",
              project.name,
              createdTasks.length,
              summary.substring(0, 200) + "..."
            );
          } catch (emailError) {
            console.log("Meeting notification email failed:", emailError);
          }
        }
      }
      res.json({
        success: true,
        meeting,
        tasksCreated: createdTasks.length,
        extractedTasks,
        transcription,
        aiSummary: summary
      });
    } catch (error) {
      console.error("Processing recording error:", error);
      res.status(500).json({
        message: "Failed to process recording",
        error: error.message || "Unknown error"
      });
    }
  });
  app2.post("/api/meetings/:id/preparation", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const meetingId = req.params.id;
      const meeting = await storage.getMeeting(meetingId);
      if (!meeting) {
        return res.status(404).json({ message: "Meeting not found" });
      }
      if (meeting.projectId) {
        const userProjects = await storage.getProjects(userId);
        const hasAccess = userProjects.some((p) => p.id === meeting.projectId);
        if (!hasAccess) {
          return res.status(403).json({ message: "Not authorized to access this meeting" });
        }
      }
      const preparation = await aiService.generateMeetingPreparation(
        meeting,
        meeting.projectId,
        userId,
        []
        // Database meetings don't have attendee emails from calendar
      );
      res.json({ preparation });
    } catch (error) {
      console.error("Meeting preparation error:", error);
      res.status(500).json({ message: "Failed to generate meeting preparation", error: error.message });
    }
  });
  app2.post("/api/meetings/comprehensive-preparation", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const comprehensiveMeeting = {
        id: "comprehensive",
        title: "Overall Project Review",
        description: "Comprehensive analysis of all projects and tasks",
        scheduledAt: /* @__PURE__ */ new Date(),
        projectId: null
      };
      const preparation = await aiService.generateMeetingPreparation(
        comprehensiveMeeting,
        null,
        // null triggers comprehensive mode
        userId,
        []
        // Comprehensive meetings don't have specific attendees
      );
      res.json({ preparation });
    } catch (error) {
      console.error("Comprehensive meeting preparation error:", error);
      res.status(500).json({ message: "Failed to generate comprehensive meeting preparation", error: error.message });
    }
  });
  app2.post("/api/projects/:projectId/meeting-preparation", requireAuth, async (req, res) => {
    try {
      const { projectId } = req.params;
      const userId = getUserId(req, mockUserId);
      console.log(`\u{1F50D} Generating project meeting preparation for project: ${projectId}, user: ${userId}`);
      const project = await storage.getProject(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      const userProjects = await storage.getProjects(userId);
      const hasAccess = userProjects.some((p) => p.id === projectId);
      if (!hasAccess) {
        return res.status(403).json({ message: "Not authorized to access this project" });
      }
      console.log(`\u{1F916} Calling AI service for project-specific preparation...`);
      const { aiService: aiService2 } = await Promise.resolve().then(() => (init_ai(), ai_exports));
      const preparation = await aiService2.generateProjectMeetingPreparation(projectId, userId);
      console.log(`\u2705 Generated project preparation: ${preparation ? "HAS_CONTENT" : "EMPTY"}`);
      res.json({ preparation });
    } catch (error) {
      console.error("Project meeting preparation error:", error);
      res.status(500).json({ message: "Failed to generate project meeting preparation", error: error.message });
    }
  });
  app2.post("/api/outlook/events/:eventId/preparation", async (req, res) => {
    console.log(`\u{1F3AF} OUTLOOK PREPARATION ENDPOINT HIT for event: ${req.params.eventId}`);
    console.log(`\u{1F3AF} ENDPOINT HIT: Outlook event preparation request starting...`);
    console.log(`\u{1F3AF} Event ID: ${req.params.eventId}`);
    console.log(`\u{1F510} Request headers:`, Object.keys(req.headers));
    console.log(`\u{1F510} Session data:`, req.session?.userId ? "HAS_SESSION" : "NO_SESSION");
    try {
      let userId;
      try {
        userId = getUserId(req, mockUserId);
        console.log(`\u{1F510} User ID resolved:`, userId ? "SUCCESS" : "FAILED");
      } catch (error) {
        console.log(`\u274C getUserId failed:`, error);
        return res.status(401).json({ preparation: "Authentication required" });
      }
      const eventId = req.params.eventId;
      console.log(`\u{1F3AF} Meeting prep request RECEIVED for Outlook event: ${eventId} by user: ${userId}`);
      console.log(`\u{1F50D} Checking user settings for Outlook configuration...`);
      const settings = await storage.getUserSettings(userId);
      console.log(`\u{1F4CB} User settings:`, settings ? "FOUND" : "NULL", settings?.outlookCalendarEnabled ? "ENABLED" : "NOT_ENABLED");
      if (!settings?.outlookCalendarEnabled || !settings?.outlookCalendarUrl) {
        console.log(`\u274C Outlook not configured properly for user ${userId}`);
        return res.status(400).json({ message: "Outlook calendar not configured" });
      }
      const { CalendarSyncService: CalendarSyncService2 } = await Promise.resolve().then(() => (init_calendar_sync(), calendar_sync_exports));
      const events = await CalendarSyncService2.fetchOutlookEvents(settings.outlookCalendarUrl);
      const event = events.find((e) => e.id === eventId);
      if (!event) {
        return res.status(404).json({ message: "Outlook event not found" });
      }
      let linkedProject = null;
      let matchedProject = null;
      console.log(`\u{1F50D} Checking for linked external meeting with eventId: ${eventId}`);
      console.log(`\u{1F50D} EventId length: ${eventId.length}, UserId: ${userId}`);
      const externalMeeting = await storage.getExternalMeetingByExternalId(eventId, userId);
      console.log(`\u{1F50D} External meeting lookup result:`, externalMeeting ? `FOUND (projectId: ${externalMeeting.projectId})` : "NOT FOUND");
      if (externalMeeting && externalMeeting.projectId) {
        console.log(`\u{1F3AF} Found linked external meeting! ProjectId: ${externalMeeting.projectId}`);
        linkedProject = await storage.getProject(externalMeeting.projectId);
        if (linkedProject) {
          console.log(`\u{1F4CB} Using linked project for meeting prep: ${linkedProject.name}`);
          matchedProject = linkedProject;
        }
      } else {
        console.log(`\u{1F50D} No linked external meeting found, trying project name matching...`);
        const userProjects = await storage.getProjects(userId);
        for (const project of userProjects) {
          const titleLower = event.title.toLowerCase();
          const projectNameLower = project.name.toLowerCase();
          if (titleLower.includes(projectNameLower) || projectNameLower.includes(titleLower) || event.description && event.description.toLowerCase().includes(projectNameLower)) {
            matchedProject = project;
            console.log(`\u{1F4CE} Matched Outlook meeting "${event.title}" with project "${project.name}"`);
            break;
          }
        }
      }
      const meetingLikeEvent = {
        id: event.id,
        title: event.title,
        description: event.description || "",
        scheduledAt: event.start.toISOString(),
        duration: Math.round((event.end.getTime() - event.start.getTime()) / (1e3 * 60)),
        projectId: null,
        // Outlook events don't have project associations
        createdById: userId
      };
      const projectId = matchedProject ? matchedProject.id : null;
      console.log(`\u{1F504} Calling AI service for ${projectId ? "project-focused" : "meeting-specific"} preparation...`);
      console.log(`\u{1F4CB} Event data:`, {
        title: meetingLikeEvent.title,
        userId,
        matchedProject: matchedProject?.name || "None",
        attendeeCount: event.attendees?.length || 0
      });
      const preparation = await aiService.generateMeetingPreparation(
        meetingLikeEvent,
        projectId,
        // Use matched project ID if found, null for meeting-specific (not comprehensive) mode
        userId,
        event.attendees || []
        // Pass attendee emails for smart action item analysis
      );
      console.log(`\u2705 Preparation generated successfully, length: ${preparation?.length || 0}`);
      console.log(`\u{1F3AF} AI service returned:`, typeof preparation, preparation ? preparation.length + " chars" : "NULL/EMPTY");
      console.log(`\u{1F4E4} Sending meeting prep response for event ${eventId}:`, { preparation: preparation ? "HAS_CONTENT" : "EMPTY" });
      console.log(`\u{1F4CB} Full preparation content preview:`, preparation?.substring(0, 100) + "...");
      if (!preparation) {
        console.log(`\u274C No preparation content generated`);
        return res.json({ preparation: "No preparation content was generated. Please try again." });
      }
      console.log(`\u2705 Sending successful response with ${preparation.length} characters`);
      return res.status(200).json({
        preparation,
        success: true,
        length: preparation.length
      });
    } catch (error) {
      console.error("\u274C Outlook event preparation error:", error);
      console.error("\u274C Error stack:", error.stack);
      return res.status(500).json({
        message: "Failed to generate meeting preparation for Outlook event",
        error: error.message,
        preparation: "Error occurred while generating preparation. Please try again."
      });
    }
  });
  app2.use("/api/outlook/events/*", (req, res, next) => {
    console.log(`\u{1F50D} DEBUG: Unmatched outlook request - Method: ${req.method}, URL: ${req.originalUrl}`);
    next();
  });
  app2.get("/api/ai/project-insights/:projectId", requireAuth, async (req, res) => {
    try {
      const projectId = req.params.projectId;
      const project = await storage.getProject(projectId);
      const tasks2 = await storage.getTasks(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      const insights = await aiService.generateProjectInsights(project, tasks2);
      res.json(insights);
    } catch (error) {
      console.error("AI insights error:", error);
      res.status(500).json({ message: error.message || "Failed to generate insights" });
    }
  });
  app2.get("/api/ai/notifications", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projects2 = await storage.getProjects(userId);
      const allTasks = [];
      for (const project of projects2) {
        const projectTasks = await storage.getTasks(project.id);
        allTasks.push(...projectTasks);
      }
      const notifications2 = await aiService.generateSmartNotifications(projects2, allTasks, userId);
      res.json(notifications2);
    } catch (error) {
      console.error("AI notifications error:", error);
      res.status(500).json({ message: error.message || "Failed to generate notifications" });
    }
  });
  app2.get("/api/ai/daily-summary", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projects2 = await storage.getProjects(userId);
      const allTasks = [];
      for (const project of projects2) {
        const projectTasks = await storage.getTasks(project.id);
        allTasks.push(...projectTasks);
      }
      const summary = await aiService.generateSmartDailyBriefing(projects2, allTasks, userId);
      res.json(summary);
    } catch (error) {
      console.error("AI daily summary error:", error);
      res.status(500).json({ message: error.message || "Failed to generate daily summary" });
    }
  });
  app2.get("/api/ai/overall-insights", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projects2 = await storage.getProjects(userId);
      const allTasks = [];
      for (const project of projects2) {
        const projectTasks = await storage.getTasks(project.id);
        allTasks.push(...projectTasks);
      }
      const completedTasks = allTasks.filter((t) => t.status === "completed").length;
      const totalTasks = allTasks.length;
      const completionRate = totalTasks > 0 ? completedTasks / totalTasks * 100 : 0;
      const upcomingDeadlines = allTasks.filter((task) => {
        if (!task.dueDate) return false;
        const dueDate = new Date(task.dueDate);
        const daysUntilDue = Math.ceil((dueDate.getTime() - Date.now()) / (1e3 * 3600 * 24));
        return daysUntilDue >= 0 && daysUntilDue <= 7;
      }).length;
      const overallInsights = {
        productivityTrend: Math.max(-50, Math.min(50, Math.round((completionRate - 50) / 2))),
        burnoutRisk: upcomingDeadlines > 5 ? "High" : upcomingDeadlines > 2 ? "Medium" : "Low",
        teamEfficiency: Math.round(completionRate),
        upcomingDeadlines
      };
      res.json(overallInsights);
    } catch (error) {
      console.error("AI overall insights error:", error);
      res.status(500).json({ message: error.message || "Failed to generate overall insights" });
    }
  });
  app2.get("/api/notifications", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const notifications2 = await storage.getNotifications(userId);
      res.json(notifications2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });
  app2.put("/api/notifications/:id/read", requireAuth, async (req, res) => {
    try {
      await storage.markNotificationRead(req.params.id);
      res.json({ message: "Notification marked as read" });
    } catch (error) {
      res.status(500).json({ message: "Failed to update notification" });
    }
  });
  app2.get("/api/settings", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const settings = await storage.getUserSettings(userId);
      res.json(settings || {});
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch settings" });
    }
  });
  app2.put("/api/settings", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const settingsData = insertUserSettingsSchema.partial().parse(req.body);
      const settings = await storage.updateUserSettings(userId, settingsData);
      res.json(settings);
    } catch (error) {
      res.status(400).json({ message: "Invalid settings data" });
    }
  });
  app2.post("/api/settings/test-email", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      await emailService.sendTestEmail(user.email);
      res.json({
        message: "Test email sent successfully",
        sentTo: user.email
      });
    } catch (error) {
      console.error("Error sending test email:", error);
      res.status(500).json({
        message: "Failed to send test email",
        error: error.message
      });
    }
  });
  app2.post("/api/ai/send-notification-email", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const user = await storage.getUser(userId);
      const { type, email: requestedEmail } = req.body;
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const targetEmail = requestedEmail || user.email;
      if (type === "daily_summary") {
        const projects2 = await storage.getProjects(userId);
        const allTasks = [];
        for (const project of projects2) {
          const projectTasks = await storage.getTasks(project.id);
          allTasks.push(...projectTasks);
        }
        const summary = await aiService.generateDailySummary(projects2, allTasks, userId);
        await emailService.sendDailySummary(targetEmail, summary);
        res.json({
          message: "Daily summary email sent successfully",
          sentTo: targetEmail
        });
      } else if (type === "test_email") {
        await emailService.sendTestEmail(targetEmail);
        res.json({
          message: "Test email sent successfully",
          sentTo: targetEmail
        });
      } else {
        res.status(400).json({ message: "Invalid email type" });
      }
    } catch (error) {
      console.error("AI notification email error:", error);
      res.status(500).json({
        message: "Failed to send notification email",
        error: error.message
      });
    }
  });
  app2.post("/api/ai/notify-project-members/:projectId", requireAuth, async (req, res) => {
    try {
      const projectId = req.params.projectId;
      const { type, message } = req.body;
      const project = await storage.getProject(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      const members = await storage.getProjectMembers(projectId);
      const emailsSent = [];
      const owner = await storage.getUser(project.ownerId);
      if (owner?.email) {
        await emailService.sendProjectAlert(owner.email, project.name, type, message);
        emailsSent.push(owner.email);
      }
      for (const member of members) {
        const memberUser = await storage.getUser(member.userId);
        if (memberUser?.email) {
          await emailService.sendProjectAlert(memberUser.email, project.name, type, message);
          emailsSent.push(memberUser.email);
        }
      }
      res.json({
        message: `Notifications sent to ${emailsSent.length} project members`,
        emailsSent: emailsSent.length,
        recipients: emailsSent
      });
    } catch (error) {
      console.error("Project member notification error:", error);
      res.status(500).json({
        message: "Failed to notify project members",
        error: error.message
      });
    }
  });
  app2.get("/api/analytics/project-prediction/:projectId", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projectId = req.params.projectId;
      const project = await storage.getProject(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      if (project.ownerId !== userId) {
        const members2 = await storage.getProjectMembers(projectId);
        const hasAccess = members2.some((member) => member.userId === userId);
        if (!hasAccess) {
          return res.status(403).json({ message: "Access denied" });
        }
      }
      const tasks2 = await storage.getTasks(projectId);
      const members = await storage.getProjectMembers(projectId);
      const teamMembers = [];
      for (const member of members) {
        const user = await storage.getUser(member.userId);
        if (user) teamMembers.push(user);
      }
      const prediction = await analyticsService.generateProjectSuccessPrediction(
        project,
        tasks2,
        teamMembers
      );
      res.json(prediction);
    } catch (error) {
      console.error("Project prediction error:", error);
      res.status(500).json({
        message: "Failed to generate project prediction",
        error: error.message
      });
    }
  });
  app2.get("/api/analytics/workload-analysis", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projects2 = await storage.getProjects(userId);
      const allTasks = [];
      for (const project of projects2) {
        const projectTasks = await storage.getTasks(project.id);
        allTasks.push(...projectTasks);
      }
      const workloadAnalysis = await analyticsService.analyzeWorkload(
        userId,
        allTasks,
        projects2
      );
      res.json(workloadAnalysis);
    } catch (error) {
      console.error("Workload analysis error:", error);
      res.status(500).json({
        message: "Failed to analyze workload",
        error: error.message
      });
    }
  });
  app2.get("/api/analytics/resource-optimization", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projects2 = await storage.getProjects(userId);
      const allTasks = [];
      const allUsers = /* @__PURE__ */ new Set();
      for (const project of projects2) {
        const projectTasks = await storage.getTasks(project.id);
        const projectMembers2 = await storage.getProjectMembers(project.id);
        allTasks.push(...projectTasks);
        allUsers.add(project.ownerId);
        projectMembers2.forEach((member) => allUsers.add(member.userId));
      }
      const teamMembers = [];
      for (const userId2 of Array.from(allUsers)) {
        const user = await storage.getUser(userId2);
        if (user) teamMembers.push(user);
      }
      const optimization = await analyticsService.optimizeResourceAllocation(
        projects2,
        allTasks,
        teamMembers
      );
      res.json(optimization);
    } catch (error) {
      console.error("Resource optimization error:", error);
      res.status(500).json({
        message: "Failed to optimize resources",
        error: error.message
      });
    }
  });
  app2.get("/api/analytics/project/:projectId", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projectId = req.params.projectId;
      const project = await storage.getProject(projectId);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      if (project.ownerId !== userId) {
        const members = await storage.getProjectMembers(projectId);
        const hasAccess = members.some((member) => member.userId === userId);
        if (!hasAccess) {
          return res.status(403).json({ message: "Access denied" });
        }
      }
      const tasks2 = await storage.getTasks(projectId);
      const analytics = await analyticsService.generateProjectAnalytics(project, tasks2);
      res.json(analytics);
    } catch (error) {
      console.error("Project analytics error:", error);
      res.status(500).json({
        message: "Failed to generate project analytics",
        error: error.message
      });
    }
  });
  app2.get("/api/analytics/dashboard", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const projects2 = await storage.getProjects(userId);
      const allTasks = [];
      const projectPredictions = [];
      for (const project of projects2) {
        const projectTasks = await storage.getTasks(project.id);
        const members = await storage.getProjectMembers(project.id);
        const teamMembers = [];
        for (const member of members) {
          const user = await storage.getUser(member.userId);
          if (user) teamMembers.push(user);
        }
        allTasks.push(...projectTasks);
        const prediction = await analyticsService.generateProjectSuccessPrediction(
          project,
          projectTasks,
          teamMembers
        );
        projectPredictions.push(prediction);
      }
      const workloadAnalysis = await analyticsService.analyzeWorkload(
        userId,
        allTasks,
        projects2
      );
      const totalTasks = allTasks.length;
      const completedTasks = allTasks.filter((t) => t.status === "completed").length;
      const overdueTasks = allTasks.filter(
        (t) => t.dueDate && new Date(t.dueDate) < /* @__PURE__ */ new Date() && t.status !== "completed"
      ).length;
      const avgSuccessProbability = projectPredictions.length > 0 ? Math.round(projectPredictions.reduce((sum, p) => sum + p.successProbability, 0) / projectPredictions.length) : 0;
      const dashboard = {
        overview: {
          totalProjects: projects2.length,
          totalTasks,
          completedTasks,
          overdueTasks,
          completionRate: totalTasks > 0 ? Math.round(completedTasks / totalTasks * 100) : 0,
          avgSuccessProbability
        },
        workload: workloadAnalysis,
        projectPredictions: projectPredictions.slice(0, 5),
        // Top 5 projects
        riskAlerts: projectPredictions.filter((p) => p.successProbability < 60).map((p) => ({
          projectId: p.projectId,
          projectName: projects2.find((proj) => proj.id === p.projectId)?.name || "Unknown",
          risk: p.successProbability,
          factors: p.riskFactors.slice(0, 2)
        })),
        recommendations: [
          ...workloadAnalysis.recommendations,
          ...projectPredictions.flatMap((p) => p.recommendations).slice(0, 3)
        ].slice(0, 5)
      };
      res.json(dashboard);
    } catch (error) {
      console.error("Analytics dashboard error:", error);
      res.status(500).json({
        message: "Failed to generate analytics dashboard",
        error: error.message
      });
    }
  });
  app2.get("/api/analytics/burnout-assessment/:userId?", requireAuth, async (req, res) => {
    try {
      const requesterId = getUserId(req, mockUserId);
      const targetUserId = req.params.userId || requesterId;
      if (targetUserId !== requesterId) {
        const projects3 = await storage.getProjects(requesterId);
        const isOwner = projects3.length > 0;
        if (!isOwner) {
          return res.status(403).json({ message: "Access denied" });
        }
      }
      const projects2 = await storage.getProjects(targetUserId);
      const allTasks = [];
      for (const project of projects2) {
        const projectTasks = await storage.getTasks(project.id);
        allTasks.push(...projectTasks);
      }
      const workloadAnalysis = await analyticsService.analyzeWorkload(
        targetUserId,
        allTasks,
        projects2
      );
      const burnoutAssessment = {
        userId: targetUserId,
        riskLevel: workloadAnalysis.burnoutRisk,
        workloadScore: workloadAnalysis.workloadScore,
        weeklyHours: workloadAnalysis.weeklyHours,
        recommendations: workloadAnalysis.recommendations,
        taskBreakdown: workloadAnalysis.taskDistribution,
        optimalCapacity: workloadAnalysis.optimalCapacity,
        interventionRequired: workloadAnalysis.burnoutRisk === "High" || workloadAnalysis.burnoutRisk === "Critical"
      };
      res.json(burnoutAssessment);
    } catch (error) {
      console.error("Burnout assessment error:", error);
      res.status(500).json({
        message: "Failed to assess burnout risk",
        error: error.message
      });
    }
  });
  app2.post("/api/outlook/configure", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const { calendarUrl, enabled } = req.body;
      if (enabled === false) {
        console.log(`\u{1F4C5} Disconnecting calendar sync for user ${userId}`);
        const keysToDelete = [];
        outlookEventCache.forEach((value, key) => {
          if (key.startsWith(`${userId}-`)) {
            keysToDelete.push(key);
          }
        });
        keysToDelete.forEach((key) => outlookEventCache.delete(key));
        console.log(`\u{1F5D1}\uFE0F Cleared ${keysToDelete.length} cached calendar entries`);
        const settings2 = await storage.updateUserSettings(userId, {
          outlookCalendarEnabled: false,
          // Optionally clear the URL when disconnecting
          outlookCalendarUrl: null
        });
        return res.json({
          message: "Calendar sync disconnected successfully",
          settings: {
            outlookCalendarUrl: settings2.outlookCalendarUrl,
            outlookCalendarEnabled: settings2.outlookCalendarEnabled
          }
        });
      }
      if (!calendarUrl || typeof calendarUrl !== "string") {
        return res.status(400).json({ message: "Calendar URL is required" });
      }
      const { CalendarSyncService: CalendarSyncService2 } = await Promise.resolve().then(() => (init_calendar_sync(), calendar_sync_exports));
      const fixedUrl = CalendarSyncService2.fixCalendarUrl(calendarUrl);
      if (!CalendarSyncService2.isValidCalendarUrl(fixedUrl)) {
        return res.status(400).json({
          message: "Invalid calendar URL format. Make sure it's an Outlook calendar URL ending with .ics"
        });
      }
      const existingCacheKeys = [];
      outlookEventCache.forEach((value, key) => {
        if (key.startsWith(`${userId}-`)) {
          existingCacheKeys.push(key);
        }
      });
      existingCacheKeys.forEach((key) => outlookEventCache.delete(key));
      console.log(`\u{1F504} Cleared ${existingCacheKeys.length} old cache entries for calendar reconfiguration`);
      const settings = await storage.updateUserSettings(userId, {
        outlookCalendarUrl: fixedUrl,
        outlookCalendarEnabled: enabled !== false
      });
      res.json({
        message: fixedUrl !== calendarUrl ? "Outlook calendar configured successfully (URL auto-corrected to .ics format)" : "Outlook calendar configured successfully",
        settings: {
          outlookCalendarUrl: settings.outlookCalendarUrl,
          outlookCalendarEnabled: settings.outlookCalendarEnabled
        }
      });
    } catch (error) {
      console.error("Outlook configure error:", error);
      res.status(500).json({ message: "Failed to configure Outlook calendar" });
    }
  });
  app2.post("/api/outlook/test", requireAuth, async (req, res) => {
    try {
      const { calendarUrl } = req.body;
      if (!calendarUrl) {
        return res.status(400).json({ message: "Calendar URL is required" });
      }
      const { CalendarSyncService: CalendarSyncService2 } = await Promise.resolve().then(() => (init_calendar_sync(), calendar_sync_exports));
      const events = await CalendarSyncService2.fetchOutlookEvents(calendarUrl);
      res.json({
        success: true,
        eventCount: events.length,
        preview: events.slice(0, 3).map((e) => ({
          title: e.title,
          start: e.start,
          location: e.location
        }))
      });
    } catch (error) {
      console.error("Outlook test error:", error);
      res.status(400).json({
        success: false,
        message: error instanceof Error ? error.message : "Failed to test calendar URL"
      });
    }
  });
  app2.post("/api/calendar/upload-ics", requireAuth, async (req, res) => {
    try {
      const { fileContent, fileName } = req.body;
      if (!fileContent || typeof fileContent !== "string") {
        return res.status(400).json({ message: "ICS file content is required" });
      }
      const { IcsParserService: IcsParserService2 } = await Promise.resolve().then(() => (init_ics_parser(), ics_parser_exports));
      if (!IcsParserService2.validateIcsFile(fileContent)) {
        return res.status(400).json({
          message: "Invalid ICS file format. Please make sure you uploaded a valid calendar file."
        });
      }
      const events = IcsParserService2.parseIcsContent(fileContent);
      const stats = IcsParserService2.getFileStats(fileContent);
      if (events.length === 0) {
        return res.status(400).json({
          message: "No events found in the calendar file."
        });
      }
      res.json({
        message: "Calendar file processed successfully!",
        stats: {
          fileName: fileName || "calendar.ics",
          eventCount: stats.eventCount,
          dateRange: stats.dateRange,
          sampleEvents: events.slice(0, 3).map((e) => ({
            title: e.title,
            start: e.start,
            location: e.location
          }))
        }
      });
    } catch (error) {
      console.error("ICS upload error:", error);
      res.status(500).json({ message: "Failed to process calendar file" });
    }
  });
  app2.post("/api/outlook/oauth/connect", requireAuth, async (req, res) => {
    try {
      res.status(501).json({
        message: "OAuth connection coming soon! This feature will be available in the next update.",
        authUrl: null
      });
    } catch (error) {
      console.error("OAuth connection error:", error);
      res.status(500).json({ message: "OAuth setup not available yet" });
    }
  });
  const outlookEventCache = /* @__PURE__ */ new Map();
  const CACHE_DURATION = 30 * 60 * 1e3;
  app2.get("/api/outlook/events", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const settings = await storage.getUserSettings(userId);
      if (!settings?.outlookCalendarUrl || !settings.outlookCalendarEnabled) {
        return res.json([]);
      }
      const forceRefresh = req.query.refresh === "true";
      const cacheKey = `${userId}-${settings.outlookCalendarUrl}`;
      const now = Date.now();
      const cached = outlookEventCache.get(cacheKey);
      if (!forceRefresh && cached && now - cached.timestamp < CACHE_DURATION) {
        console.log(`Serving cached Outlook events (${cached.events.length} events, cache age: ${Math.round((now - cached.timestamp) / 1e3 / 60)} minutes)`);
        return res.json(cached.events);
      }
      const { CalendarSyncService: CalendarSyncService2 } = await Promise.resolve().then(() => (init_calendar_sync(), calendar_sync_exports));
      try {
        const events = await CalendarSyncService2.fetchOutlookEvents(settings.outlookCalendarUrl);
        console.log(`Successfully synced ${events.length} Outlook events - updating cache`);
        console.log(`\u26A1 Optimizing sync: Processing ${events.length} events with batch operations`);
        const existingMeetings = await storage.getExternalMeetings(userId);
        const existingMap = /* @__PURE__ */ new Map();
        existingMeetings.forEach((meeting) => {
          existingMap.set(meeting.externalId, meeting);
        });
        const userProjects = await storage.getProjects(userId);
        const projectMap = /* @__PURE__ */ new Map();
        userProjects.forEach((project) => {
          projectMap.set(project.id, project.name);
        });
        console.log(`\u{1F4CA} Found ${existingMeetings.length} existing meetings in database`);
        const processedEvents = [];
        const meetingsToUpdate = [];
        const meetingsToCreate = [];
        for (const event of events) {
          const existingMeeting = existingMap.get(event.id);
          if (existingMeeting) {
            meetingsToUpdate.push({
              id: existingMeeting.id,
              updates: {
                title: event.title,
                description: event.description,
                startTime: event.start,
                endTime: event.end,
                location: event.location,
                attendees: event.attendees || [],
                // CRITICAL: Preserve existing projectId link
                projectId: existingMeeting.projectId
              },
              event,
              projectId: existingMeeting.projectId
            });
          } else {
            meetingsToCreate.push({
              externalId: event.id,
              userId,
              projectId: null,
              title: event.title,
              description: event.description,
              startTime: event.start,
              endTime: event.end,
              location: event.location,
              attendees: event.attendees || [],
              source: "outlook",
              event
            });
          }
        }
        console.log(`\u{1F504} Updating ${meetingsToUpdate.length} existing meetings, creating ${meetingsToCreate.length} new ones`);
        for (const item of meetingsToUpdate) {
          try {
            await storage.updateExternalMeeting(item.id, item.updates);
            processedEvents.push({
              ...item.event,
              projectId: item.projectId,
              projectName: item.projectId ? projectMap.get(item.projectId) : void 0,
              dbId: item.id
            });
          } catch (error) {
            console.error(`Error updating meeting ${item.event.title}:`, error);
            processedEvents.push(item.event);
          }
        }
        for (const meetingData of meetingsToCreate) {
          try {
            const newMeeting = await storage.createExternalMeeting(meetingData);
            processedEvents.push({
              ...meetingData.event,
              projectId: null,
              dbId: newMeeting.id
            });
          } catch (error) {
            console.error(`Error creating meeting ${meetingData.title}:`, error);
            processedEvents.push(meetingData.event);
          }
        }
        const eventsWithProjectNames = processedEvents.map((event) => {
          if (event.projectId && !event.projectName) {
            const projectName = projectMap.get(event.projectId);
            return {
              ...event,
              projectName
            };
          }
          return event;
        });
        outlookEventCache.set(cacheKey, {
          events: eventsWithProjectNames,
          timestamp: now
        });
        console.log(`\u2705 Processed ${processedEvents.length} Outlook events with database persistence`);
        res.json(processedEvents);
      } catch (syncError) {
        console.error("Calendar sync failed:", syncError);
        if (cached) {
          console.log(`Calendar sync failed, serving stale cached data (${cached.events.length} events)`);
          try {
            const dbMeetings = await storage.getExternalMeetings(userId);
            if (dbMeetings.length > 0) {
              console.log(`\u{1F4C1} Serving ${dbMeetings.length} meetings from database as backup`);
              const userProjects = await storage.getProjects(userId);
              const fallbackProjectMap = /* @__PURE__ */ new Map();
              userProjects.forEach((project) => {
                fallbackProjectMap.set(project.id, project.name);
              });
              const dbEvents = dbMeetings.map((meeting) => ({
                id: meeting.externalId,
                title: meeting.title,
                description: meeting.description,
                start: meeting.startTime,
                end: meeting.endTime,
                location: meeting.location,
                attendees: meeting.attendees || [],
                source: meeting.source,
                projectId: meeting.projectId,
                projectName: meeting.projectId ? fallbackProjectMap.get(meeting.projectId) : void 0,
                dbId: meeting.id
              }));
              return res.json(dbEvents);
            }
          } catch (dbError) {
            console.error("Database fallback failed:", dbError);
          }
          return res.json(cached.events);
        }
        try {
          const dbMeetings = await storage.getExternalMeetings(userId);
          console.log(`\u{1F4C1} No cache available, serving ${dbMeetings.length} meetings from database`);
          const dbEvents = dbMeetings.map((meeting) => ({
            id: meeting.externalId,
            title: meeting.title,
            description: meeting.description,
            start: meeting.startTime,
            end: meeting.endTime,
            location: meeting.location,
            attendees: meeting.attendees || [],
            source: meeting.source,
            projectId: meeting.projectId,
            dbId: meeting.id
          }));
          res.json(dbEvents);
        } catch (dbError) {
          console.error("Database fallback failed:", dbError);
          res.json([]);
        }
      }
    } catch (error) {
      console.error("Outlook events error:", error);
      res.status(500).json({ message: "Failed to fetch Outlook events" });
    }
  });
  app2.post("/api/outlook/events/sync", requireAuth, async (req, res) => {
    try {
      const accessToken = req.headers.authorization?.replace("Bearer ", "");
      if (!accessToken) {
        return res.status(401).json({ message: "Outlook not connected" });
      }
      const event = await OutlookService.createCalendarEvent(accessToken, req.body);
      res.json(event);
    } catch (error) {
      console.error("Outlook create event error:", error);
      res.status(500).json({ message: "Failed to create Outlook event" });
    }
  });
  app2.get("/api/invitations/accept/:token", async (req, res) => {
    try {
      const { token } = req.params;
      const invitation = await storage.getInvitation(token);
      if (!invitation) {
        return res.status(404).json({ message: "Invitation not found or invalid" });
      }
      if (invitation.status !== "pending") {
        return res.status(400).json({
          message: `Invitation already ${invitation.status}`,
          status: invitation.status
        });
      }
      if (/* @__PURE__ */ new Date() > invitation.expiresAt) {
        await storage.updateInvitation(token, {
          status: "expired",
          respondedAt: /* @__PURE__ */ new Date()
        });
        return res.status(400).json({ message: "Invitation has expired" });
      }
      const existingUser = await storage.getUserByEmail(invitation.inviteeEmail);
      if (!existingUser) {
        return res.redirect(`/register?invitation=${token}`);
      }
      const currentUserId = req.session?.userId;
      if (!currentUserId || currentUserId !== existingUser.id) {
        return res.redirect(`/login?invitation=${token}`);
      }
      const existingMembers = await storage.getProjectMembers(invitation.project.id);
      const isAlreadyMember = existingMembers.some((m) => m.userId === existingUser.id);
      if (!isAlreadyMember) {
        await storage.addProjectMember({
          projectId: invitation.project.id,
          userId: existingUser.id,
          role: invitation.role
        });
      }
      await storage.updateInvitation(token, {
        status: "accepted",
        respondedAt: /* @__PURE__ */ new Date()
      });
      await storage.createNotification({
        userId: existingUser.id,
        title: "Project Invitation Accepted",
        message: `Welcome to "${invitation.project.name}"! You've been added as a ${invitation.role}.`,
        type: "project",
        data: { projectId: invitation.project.id, projectName: invitation.project.name }
      });
      res.redirect(`/projects/${invitation.project.id}`);
    } catch (error) {
      console.error("Accept invitation error:", error);
      res.status(500).json({ message: "Failed to accept invitation", error: error.message });
    }
  });
  app2.get("/api/invitations/decline/:token", async (req, res) => {
    try {
      const { token } = req.params;
      const invitation = await storage.getInvitation(token);
      if (!invitation) {
        return res.status(404).json({ message: "Invitation not found or invalid" });
      }
      if (invitation.status !== "pending") {
        return res.status(400).json({
          message: `Invitation already ${invitation.status}`,
          status: invitation.status
        });
      }
      await storage.updateInvitation(token, {
        status: "declined",
        respondedAt: /* @__PURE__ */ new Date()
      });
      res.send(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Invitation Declined</title>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <style>
            body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
            .container { background: #f9f9f9; padding: 30px; border-radius: 12px; border-left: 4px solid #6B7280; }
            h1 { color: #374151; margin: 0 0 20px 0; }
            p { color: #6B7280; line-height: 1.6; margin: 0; }
          </style>
        </head>
        <body>
          <div class="container">
            <h1>\u274C Invitation Declined</h1>
            <p>You have declined the invitation to join "${invitation.project.name}".</p>
            <p style="margin-top: 15px;">If you change your mind, please contact ${invitation.inviter.name} directly.</p>
          </div>
        </body>
        </html>
      `);
    } catch (error) {
      console.error("Decline invitation error:", error);
      res.status(500).json({ message: "Failed to decline invitation", error: error.message });
    }
  });
  app2.get("/api/invitations/:token", async (req, res) => {
    try {
      const { token } = req.params;
      const invitation = await storage.getInvitation(token);
      if (!invitation) {
        return res.status(404).json({ message: "Invitation not found or invalid" });
      }
      if (invitation.status !== "pending") {
        return res.status(400).json({
          message: `Invitation already ${invitation.status}`,
          status: invitation.status
        });
      }
      if (/* @__PURE__ */ new Date() > invitation.expiresAt) {
        return res.status(400).json({ message: "Invitation has expired" });
      }
      res.json({
        projectName: invitation.project.name,
        inviterName: invitation.inviter.name,
        role: invitation.role,
        inviteeEmail: invitation.inviteeEmail,
        expiresAt: invitation.expiresAt
      });
    } catch (error) {
      console.error("Get invitation error:", error);
      res.status(500).json({ message: "Failed to get invitation details" });
    }
  });
  app2.get("/api/my-invitations", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const invitations2 = await storage.getInvitationsByEmail(user.email);
      const pendingInvitations = invitations2.filter(
        (inv) => inv.status === "pending" && /* @__PURE__ */ new Date() < inv.expiresAt
      );
      res.json(pendingInvitations);
    } catch (error) {
      console.error("Get my invitations error:", error);
      res.status(500).json({ message: "Failed to get invitations" });
    }
  });
  app2.post("/api/invitations/:id/accept", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const { id } = req.params;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const userInvitations = await storage.getInvitationsByEmail(user.email);
      const invitation = userInvitations.find((inv) => inv.id === id);
      if (!invitation) {
        return res.status(404).json({ message: "Invitation not found" });
      }
      if (invitation.status !== "pending") {
        return res.status(400).json({
          message: `Invitation already ${invitation.status}`
        });
      }
      if (/* @__PURE__ */ new Date() > invitation.expiresAt) {
        await storage.updateInvitation(invitation.token, {
          status: "expired",
          respondedAt: /* @__PURE__ */ new Date()
        });
        return res.status(400).json({ message: "Invitation has expired" });
      }
      const existingMembers = await storage.getProjectMembers(invitation.project.id);
      const isAlreadyMember = existingMembers.some((m) => m.userId === userId);
      if (!isAlreadyMember) {
        await storage.addProjectMember({
          projectId: invitation.project.id,
          userId,
          role: invitation.role
        });
      }
      await storage.updateInvitation(invitation.token, {
        status: "accepted",
        respondedAt: /* @__PURE__ */ new Date()
      });
      await storage.createNotification({
        userId,
        title: "Invitation Accepted",
        message: `Welcome to "${invitation.project.name}"! You've been added as a ${invitation.role}.`,
        type: "project",
        data: { projectId: invitation.project.id, projectName: invitation.project.name }
      });
      res.json({
        message: "Invitation accepted successfully",
        projectId: invitation.project.id,
        projectName: invitation.project.name
      });
    } catch (error) {
      console.error("Accept invitation error:", error);
      res.status(500).json({ message: "Failed to accept invitation", error: error.message });
    }
  });
  app2.post("/api/invitations/:id/decline", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const { id } = req.params;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const userInvitations = await storage.getInvitationsByEmail(user.email);
      const invitation = userInvitations.find((inv) => inv.id === id);
      if (!invitation) {
        return res.status(404).json({ message: "Invitation not found" });
      }
      if (invitation.status !== "pending") {
        return res.status(400).json({
          message: `Invitation already ${invitation.status}`
        });
      }
      await storage.updateInvitation(invitation.token, {
        status: "declined",
        respondedAt: /* @__PURE__ */ new Date()
      });
      res.json({
        message: "Invitation declined",
        projectName: invitation.project.name
      });
    } catch (error) {
      console.error("Decline invitation error:", error);
      res.status(500).json({ message: "Failed to decline invitation", error: error.message });
    }
  });
  app2.post("/api/daily-briefing/send", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      const user = await storage.getUser(userId);
      if (!user?.email) {
        return res.status(400).json({ message: "User email not found" });
      }
      const projects2 = await storage.getProjects(userId);
      const tasks2 = await storage.getTasks(void 0, userId);
      const summary = await aiService.generateSmartDailyBriefing(projects2, tasks2, userId);
      await emailService.sendDailySummary(user.email, summary);
      console.log(`Manual daily briefing sent to: ${user.email}`);
      res.json({
        message: "Daily briefing sent successfully to your email",
        email: user.email,
        summary,
        emailSent: true
      });
    } catch (error) {
      console.error("Manual daily briefing error:", error);
      res.status(500).json({ message: "Failed to send daily briefing", error: error.message });
    }
  });
  app2.post("/api/daily-briefing/enable", requireAuth, async (req, res) => {
    try {
      const userId = getUserId(req, mockUserId);
      let settings = await storage.getUserSettings(userId);
      if (!settings) {
        settings = await storage.createUserSettings({
          userId,
          emailNotifications: true,
          morningBriefing: true,
          taskDeadlineAlerts: true,
          endOfDaySummary: true,
          urgentOnly: false,
          workingHoursStart: "09:00",
          workingHoursEnd: "18:00"
        });
      } else {
        settings = await storage.updateUserSettings(userId, {
          ...settings,
          emailNotifications: true,
          morningBriefing: true
        });
      }
      res.json({
        message: "Daily briefings enabled successfully",
        settings
      });
    } catch (error) {
      console.error("Enable daily briefing error:", error);
      res.status(500).json({ message: "Failed to enable daily briefings", error: error.message });
    }
  });
  app2.post("/api/test/morning-briefing", requireAuth, async (req, res) => {
    try {
      const { scheduler: scheduler2 } = await Promise.resolve().then(() => (init_scheduler(), scheduler_exports));
      await scheduler2.sendMorningBriefings();
      res.json({ message: "Morning briefings triggered successfully" });
    } catch (error) {
      console.error("Failed to trigger morning briefings:", error);
      res.status(500).json({ message: "Failed to trigger morning briefings", error: error.message });
    }
  });
  app2.post("/api/test/lunch-reminder", requireAuth, async (req, res) => {
    try {
      const { scheduler: scheduler2 } = await Promise.resolve().then(() => (init_scheduler(), scheduler_exports));
      await scheduler2.sendLunchReminders();
      res.json({ message: "Lunch reminders triggered successfully" });
    } catch (error) {
      console.error("Failed to trigger lunch reminders:", error);
      res.status(500).json({ message: "Failed to trigger lunch reminders", error: error.message });
    }
  });
  app2.post("/api/test/end-of-day", requireAuth, async (req, res) => {
    try {
      const { scheduler: scheduler2 } = await Promise.resolve().then(() => (init_scheduler(), scheduler_exports));
      await scheduler2.sendEndOfDaySummary();
      res.json({ message: "End-of-day summaries triggered successfully" });
    } catch (error) {
      console.error("Failed to trigger end-of-day summaries:", error);
      res.status(500).json({ message: "Failed to trigger end-of-day summaries", error: error.message });
    }
  });
  app2.get("/api/debug/users-count", async (req, res) => {
    try {
      const allUsers = await storage.getAllUsers();
      const usersWithEmails = allUsers.filter((u) => u.email);
      res.json({
        totalUsers: allUsers.length,
        usersWithEmails: usersWithEmails.length,
        users: usersWithEmails.map((u) => ({
          id: u.id,
          email: u.email,
          name: u.name
        }))
      });
    } catch (error) {
      console.error("Debug users count error:", error);
      res.status(500).json({ error: "Failed to get users count" });
    }
  });
  app2.post("/api/debug/trigger-briefing", async (req, res) => {
    try {
      const { scheduler: scheduler2 } = await Promise.resolve().then(() => (init_scheduler(), scheduler_exports));
      await scheduler2.sendMorningBriefings();
      res.json({ message: "Morning briefing triggered manually", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
    } catch (error) {
      console.error("Debug briefing trigger error:", error);
      res.status(500).json({ error: "Failed to trigger briefing" });
    }
  });
  app2.post("/api/debug/test-lunch-briefings", async (req, res) => {
    try {
      const { scheduler: scheduler2 } = await Promise.resolve().then(() => (init_scheduler(), scheduler_exports));
      console.log("\u{1F957} TESTING: Manual lunch briefings triggered");
      await scheduler2.sendLunchReminders();
      res.json({
        message: "Lunch briefings test completed - check logs",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("Test lunch briefings error:", error);
      res.status(500).json({ error: "Failed to test lunch briefings" });
    }
  });
  app2.post("/api/debug/fix-user-settings", async (req, res) => {
    try {
      const allUsers = await storage.getAllUsers();
      let fixedCount = 0;
      for (const user of allUsers) {
        const settings = await storage.getUserSettings(user.id);
        if (settings) {
          const updates = {};
          if (settings.lunchReminder === void 0 || settings.lunchReminder === null) {
            updates.lunchReminder = true;
            fixedCount++;
          }
          if (Object.keys(updates).length > 0) {
            await storage.updateUserSettings(user.id, updates);
            console.log(`Fixed settings for ${user.email}: ${JSON.stringify(updates)}`);
          }
        }
      }
      res.json({
        message: `Fixed settings for ${fixedCount} users`,
        totalUsers: allUsers.length,
        fixedCount,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("Fix user settings error:", error);
      res.status(500).json({ error: "Failed to fix user settings" });
    }
  });
  app2.post("/api/debug/test-emails", async (req, res) => {
    try {
      console.log("\u{1F9EA} DEBUG: Manual email test triggered");
      const { scheduler: scheduler2 } = await Promise.resolve().then(() => (init_scheduler(), scheduler_exports));
      console.log("Testing end-of-day summaries...");
      await scheduler2.sendEndOfDaySummary();
      console.log("Testing urgent notifications (task deadlines)...");
      await scheduler2.checkUrgentNotifications();
      console.log("Testing project health alerts...");
      await scheduler2.checkProjectHealth();
      res.json({
        message: "Debug email test completed - check server logs for results",
        time: (/* @__PURE__ */ new Date()).toLocaleString()
      });
    } catch (error) {
      console.error("Debug email test failed:", error);
      res.status(500).json({
        message: "Debug email test failed",
        error: error.message,
        time: (/* @__PURE__ */ new Date()).toLocaleString()
      });
    }
  });
  app2.post("/api/debug/trigger-morning-briefings", async (req, res) => {
    try {
      console.log("\u{1F4E7} EMERGENCY: Manual morning briefing triggered for all users");
      const { scheduler: scheduler2 } = await Promise.resolve().then(() => (init_scheduler(), scheduler_exports));
      console.log("\u{1F4E7} Starting morning briefings...");
      await scheduler2.sendMorningBriefings();
      console.log("\u{1F4E7} Morning briefings completed");
      res.json({
        message: "Emergency morning briefings triggered successfully",
        time: (/* @__PURE__ */ new Date()).toLocaleString()
      });
    } catch (error) {
      console.error("Emergency morning briefing failed:", error);
      res.status(500).json({
        message: "Emergency morning briefing failed",
        error: error.message,
        time: (/* @__PURE__ */ new Date()).toLocaleString()
      });
    }
  });
  const { aiRoutes: aiRoutes2 } = await Promise.resolve().then(() => (init_ai2(), ai_exports2));
  for (const route of aiRoutes2) {
    if (route.method === "GET") {
      app2.get(`/api/ai${route.path}`, requireAuth, route.handler);
    } else if (route.method === "POST") {
      app2.post(`/api/ai${route.path}`, requireAuth, route.handler);
    } else if (route.method === "PUT") {
      app2.put(`/api/ai${route.path}`, requireAuth, route.handler);
    } else if (route.method === "DELETE") {
      app2.delete(`/api/ai${route.path}`, requireAuth, route.handler);
    }
  }
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json({ limit: "50mb" }));
app.use(express2.urlencoded({ limit: "50mb", extended: true }));
app.use(session({
  secret: process.env.SESSION_SECRET || "dev-secret-key-change-in-production",
  resave: true,
  // Save session even if not modified
  saveUninitialized: false,
  rolling: true,
  // Reset expiration on activity
  cookie: {
    secure: false,
    // Set to true in production with HTTPS
    httpOnly: true,
    maxAge: 1e3 * 60 * 60 * 24 * 30,
    // 30 days for better persistence
    sameSite: "lax"
  },
  name: "ai-project-hub-session"
  // Custom session name
}));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  const { scheduler: scheduler2 } = await Promise.resolve().then(() => (init_scheduler(), scheduler_exports));
  scheduler2.start();
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = parseInt(process.env.PORT || "5000", 10);
  process.on("SIGINT", async () => {
    log("Shutting down gracefully...");
    const { scheduler: scheduler3 } = await Promise.resolve().then(() => (init_scheduler(), scheduler_exports));
    scheduler3.stop();
    process.exit(0);
  });
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
    log("AI notification scheduler started");
  });
})();